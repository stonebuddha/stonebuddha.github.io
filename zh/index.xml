<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>王迪</title>
    <link>https://stonebuddha.github.io/zh/</link>
      <atom:link href="https://stonebuddha.github.io/zh/index.xml" rel="self" type="application/rss+xml" />
    <description>王迪</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>zh</language><lastBuildDate>Sat, 29 Jul 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://stonebuddha.github.io/media/icon_hub0ca2310ff82550007847b11be674ab8_14787_512x512_fill_lanczos_center_3.png</url>
      <title>王迪</title>
      <link>https://stonebuddha.github.io/zh/</link>
    </image>
    
    <item>
      <title>Newtonian Program Analysis of Probabilistic Programs</title>
      <link>https://stonebuddha.github.io/zh/publication/wangr23/</link>
      <pubDate>Sat, 29 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/zh/publication/wangr23/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Probabilistic Resource-Aware Session Types</title>
      <link>https://stonebuddha.github.io/zh/publication/daswh23/</link>
      <pubDate>Sun, 15 Jan 2023 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/zh/publication/daswh23/</guid>
      <description></description>
    </item>
    
    <item>
      <title>随便聊聊：贝叶斯概率编程</title>
      <link>https://stonebuddha.github.io/zh/post/introduction-to-probabilistic-programming/</link>
      <pubDate>Sun, 30 Oct 2022 17:49:57 +0800</pubDate>
      <guid>https://stonebuddha.github.io/zh/post/introduction-to-probabilistic-programming/</guid>
      <description>&lt;p&gt;人们近年来在人工智能领域取得的进展，除了层出不穷的新算法，也仰仗硬件算力的提升并得益于编程语言层面对自动微分和张量运算的支持。
基于神经网络的机器学习在很多应用中取得了成功，但在一些方面也尚存不足，例如对预测结果信度的评估&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，纳入领域知识的方法&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;，以及在观测数据的分布发生改变时的鲁棒性&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。
&lt;strong&gt;贝叶斯推断&lt;/strong&gt;（Bayesian Inference）是一种历史悠久的、基于&lt;strong&gt;概率&lt;/strong&gt;的贝叶斯解释（而非频率解释）的、在上述三个方面有一些优势的机器学习方法，其核心在于通过观测数据来估计模型假设空间的概率分布，而非选择出单个“最优”假设：设 $\Theta$ 为假设空间、$x$ 为观测数据，每个假设 $\theta \in \Theta$ 具有一个先验概率 $\mathbb{P}(\theta)$，而一个贝叶斯模型则描述了观测数据在给定假设下的条件概率 $\mathbb{P}(x \mid \theta)$，那么由贝叶斯法则，我们可用观测数据更新模型假设的后验概率：
$$
\mathbb{P}(\theta \mid x) = \frac{ \mathbb{P}(x \mid \theta) \mathbb{P}(\theta) }{ \sum_{\theta&amp;rsquo; \in \Theta} \mathbb{P}(x \mid \theta&amp;rsquo;) \mathbb{P}(\theta&amp;rsquo;) } \qquad (\theta \in \Theta).
$$
基于贝叶斯推断的机器学习也被称为&lt;strong&gt;贝叶斯机器学习&lt;/strong&gt;&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;。
然而，相比基于梯度下降等算法的机器学习方法，贝叶斯推断的计算复杂度更高，这阻挡了贝叶斯机器学习在更多领域、更大模型上的应用。&lt;/p&gt;
&lt;p&gt;为了更快更好地进行贝叶斯推断，&lt;strong&gt;概率编程&lt;/strong&gt;&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;逐渐成为一个活跃的研究领域。
概率编程旨在分离描述概率模型和进行贝叶斯推断这两个步骤，通过良好的编程语言设计来支持丰富的模型种类，通过编程语言的各类技术（如编译优化、动态分析、元编程等）来自动、高效地进行贝叶斯推断。
人们已经设计、开发了多个概率编程语言（如 Stan、Pyro、Gen.jl 等），但如何平衡&lt;strong&gt;正确性&lt;/strong&gt;和&lt;strong&gt;灵活性&lt;/strong&gt;仍然是该领域的一个重要研究问题。
一方面，设计有语义限制的概率编程语言并提供特化的推断算法，可以保证正确性和高效性，但是语言可表达的模型种类受限，也难以重用已有的非概率的计算模块；另一方面，使用通用编程语言来描述概率模型，并允许用户对通用推断算法进行定制，可以满足灵活性和一定程度上的高效性&lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:8&#34;&gt;&lt;a href=&#34;#fn:8&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;，但是用户定制会使得正确性的保证变得困难。
正如自动微分框架驱动了基于神经网络的机器学习的发展，我们期待一个&lt;strong&gt;正确而灵活的概率编程框架&lt;/strong&gt;能驱动贝叶斯机器学习的进一步发展和流行。&lt;/p&gt;
&lt;p&gt;在这里，我们看一个使用概率编程来进行时间序列的在线学习的例子&lt;sup id=&#34;fnref:9&#34;&gt;&lt;a href=&#34;#fn:9&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;9&lt;/a&gt;&lt;/sup&gt;。
该例子希望学习并预测美国的月度民航总里程数的走势（&lt;a href=&#34;https://fred.stlouisfed.org/series/RPM&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数据来源&lt;/a&gt;）。下图为 2009 年 1 月至 2020 年 2 月的数据：
&lt;a href=&#34;airline.png&#34;&gt;&lt;img src=&#34;airline.png&#34; width=&#34;500&#34;/&gt;&lt;/a&gt;
在贝叶斯机器学习中，高斯过程回归（Gaussian Process Regression）是一种灵活的算法，该方法允许我们使用核函数（Kernel Function）来定制多元高斯分布的的协方差矩阵。
通过概率编程，我们可以不用预先指定使用什么形式的核函数，而是写一段程序来声明核函数形式的先验概率分布（换句话说，我们可以把&lt;strong&gt;结构&lt;/strong&gt;的选择也纳入模型假设 $\theta$ 中）。
下面的代码通过概率上下文无关文法（Probabilistic Context-Free Grammar）的方式实现了这样的一个先验概率分布：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ocaml&#34; data-lang=&#34;ocaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Constant&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;of&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Linear&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;of&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Plus&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;of&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;rec&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel_prior&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel_type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;categorical&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;in&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;match&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel_type&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;with&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Constant&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rand&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;(* Constant (C): k(x, x&amp;#39;) = C *)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Linear&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rand&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;(* Linear (C): k(x, x&amp;#39;) = (x - C) * (x&amp;#39; - C) *)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Plus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kernel_prior&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel_prior&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;(* Plus (k1, k2): k(x, x&amp;#39;) = k1(x, x&amp;#39;) + k2(x, x&amp;#39;) *)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结合序列蒙特卡洛（Sequential Monte Carlo）方法，我们可以实现一个基于高斯过程的时间序列的在线学习算法，该算法可以估计预测的不确定性，并在数据分布发生改变时即时响应。
下面这个动画展示了在线学习的效果，其中灰色的区域为使用 100 个对后验概率分布的采样做出的 95% 置信度预测区间的叠加：
&lt;a href=&#34;airline1.gif&#34;&gt;&lt;img src=&#34;airline1.gif&#34; width=&#34;500&#34;/&gt;&lt;/a&gt;
可以看出，在数据比较多的时候，算法已经对整个趋势的掌握已经非常不错了。而下面的动画则展示在 2020 年 2 月之后的数据上的效果：
&lt;a href=&#34;airline2.gif&#34;&gt;&lt;img src=&#34;airline2.gif&#34; width=&#34;500&#34;/&gt;&lt;/a&gt;
很明显，新冠疫情导致了民航数据的突变，而基于贝叶斯推断的在线学习可以及时对这种变化进行响应并调整之后的预测。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Chuan Guo, Geoff Pleiss, Yu Sun, and Kilian Q. Weinberger. 2017. On Calibration of Modern Neural Networks. &lt;em&gt;ICML&#39;17&lt;/em&gt;.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Nikhil Muralidhar, Mohammad Raihanul Islam, Manish Marwah, Anuj Karpatne, and Naren Ramakrishnan. 2018. Incorporating Prior Domain Knowledge into Deep Neural Networks. &lt;em&gt;ICBD&#39;18&lt;/em&gt;.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;Dario Amodei, Chris Olah, Jacob Steinhardt, Paul Christiano, John Schulman,and Dan Mané. 2016. Concrete Problems in AI Safety. &lt;a href=&#34;https://arxiv.org/abs/1606.06565&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://arxiv.org/abs/1606.06565&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;Zoubin Ghahramani. 2015. Probabilistic machine learning and artiicial intelligence. &lt;em&gt;Nature&lt;/em&gt;, 521.&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;
&lt;p&gt;Joshua B. Tenenbaum, Charles Kemp, Thomas L. Grifiths, and Noah D. Goodman. 2011. How to Grow a Mind: Statistics, Structure, and Abstraction. &lt;em&gt;Science&lt;/em&gt;, 331, 6022.&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34;&gt;
&lt;p&gt;Jan Willem van de Meent, Brooks Paige, Hongseok Yang, and Frank Wood. 2018. An Introduction to Probabilistic Programming. &lt;a href=&#34;https://arxiv.org/abs/1809.10756&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://arxiv.org/abs/1809.10756&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34;&gt;
&lt;p&gt;Vikash K. Mansinghka, Ulrich Schaechtle, Shivam Handa, Alexey Radul, Yutian Chen, and Martin C. Rinard. 2018. Probabilistic Programming with Programmable Inference. &lt;em&gt;PLDI&#39;18&lt;/em&gt;.&amp;#160;&lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:8&#34;&gt;
&lt;p&gt;Eli Bingham, Jonathan P. Chen, Martin Jankowiak, Fritz Obermeyer, Neeraj Pradhan, Theofanis Karaletsos, Rishabh Singh, Paul Szerlip, Paul Horsfall, and Noah D. Goodman. 2018. Pyro: Deep Universal Probabilistic Programming. &lt;em&gt;J. Machine Learning Research&lt;/em&gt;, 20, 1.&amp;#160;&lt;a href=&#34;#fnref:8&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:9&#34;&gt;
&lt;p&gt;Feras A. Saad, Marco F. Cusumano-Towner, Ulrich Schaechtle, Martin C. Rinard, and Vikash K. Mansinghka. 2019. Bayesian Synthesis of Probabilistic Programs for Automatic Data. &lt;em&gt;POPL&#39;19&lt;/em&gt;.&amp;#160;&lt;a href=&#34;#fnref:9&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>随便聊聊：代数程序分析</title>
      <link>https://stonebuddha.github.io/zh/post/introduction-to-algebraic-program-analysis/</link>
      <pubDate>Sun, 02 Oct 2022 22:51:11 +0800</pubDate>
      <guid>https://stonebuddha.github.io/zh/post/introduction-to-algebraic-program-analysis/</guid>
      <description>&lt;p&gt;本文参考了 Zachary Kincaid 和 Thomas Reps 在 CAV 2021 上的关于&lt;strong&gt;代数程序分析&lt;/strong&gt;（Algebraic Program Analysis）的教程&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;代数程序分析简单来说就是一种基于&lt;strong&gt;代数结构&lt;/strong&gt;来设计程序分析的方法论：某种代数结构中的元素代表了程序的含义，而其上的运算则代表组合程序含义的方式。
这其实跟我们在程序语法树上用结构递归定义指称语义（Denotational Semantics）的方式类似：
$$
\begin{align}
\mathcal{A}[{-}] &amp;amp; : \mathit{Program} \to \mathit{Meaning} \\
\mathcal{A}[S_1;S_2] &amp;amp; = \mathcal{A}[S_1] \cdot \mathcal{A}[S_2] \\
\mathcal{A}[\mathbf{if}(*)\{S_1\}\mathbf{else}\{S_2\}] &amp;amp; = \mathcal{A}[S_1] + \mathcal{A}[S_2] \\
\mathcal{A}[\mathbf{while}(*)\{S_0\}] &amp;amp; = (\mathcal{A}[S_0])^*
\end{align}
$$
而上面式子中的 $\cdot$、$+$ 和 $^*$ 就可以视作某种代数结构所支持的运算。
这种方式具有良好的 Compositionality：&lt;strong&gt;一个程序的含义总是由该程序的组成部分的含义结合而来&lt;/strong&gt;。
例如，如果上面的 $\mathcal{A}$ 代表了一个程序分析，那么我们需要指定如何实现连接（$\cdot$）、分支（$+$）和循环（$^*$）这三种运算。
注意，这里出现了一个与传统基于&lt;strong&gt;迭代&lt;/strong&gt;的程序分析的重要不同：一个循环语句的含义并不是由反复迭代循环体直到不动点来获得，而是通过一个&lt;strong&gt;显式&lt;/strong&gt;的 $^*$ 运算来获得。
换句话说，代数程序分析允许我们使用别的（非迭代的）方式来分析循环，这就为我们设计新的程序分析技术提供了可能性。&lt;/p&gt;
&lt;p&gt;在本文中，我们考虑通过&lt;strong&gt;状态转移公式代数&lt;/strong&gt;（Transition Formula Alegebras）来分析程序变量间的数值关系。
一个状态转移公式$F(X,X&amp;rsquo;)$是一个逻辑公式，它描述了程序状态上的转移关系：$X$ 集合表示前状态（pre-state）的变量，$X&amp;rsquo;$ 集合表示后状态（post-state）的变量。
比如我们考虑变量有 $x,y$，那么程序语句 &lt;code&gt;x = x + 1;&lt;/code&gt; 的状态转移公式就是 $x&amp;rsquo; = x + 1 \wedge y&amp;rsquo; = y$。
对于一个固定的变量集合 $X$，我们考虑在所有可能的状态转移公式 $F(X,X&amp;rsquo;)$ 上建立一个适用于程序分析的代数结构。
在传统程序分析中，我们往往需要预先对可能的公式&lt;strong&gt;进行限制&lt;/strong&gt;来使得迭代算法可以收敛：例如，只考虑变量间的线性不等式。
在代数程序分析中，我们不需要这种预先的限制，而是可以在实现循环运算（$^*$）时以即插即用的方式使用不同的近似方法。
在状态转移公式代数中，我们定义常数 $0$ 为 $\mathit{false}$，常数 $1$ 为 $\bigwedge_{x \in X} (x&amp;rsquo; = x)$，分支运算为 $F + G = F \vee G$，连接运算为 $F \cdot G = \exists X&amp;rsquo;&amp;rsquo;. F(X,X&amp;rsquo;&amp;rsquo;) \wedge G(X&amp;rsquo;&amp;rsquo;,X&amp;rsquo;)$（即用 $X&amp;rsquo;&amp;rsquo;$ 来表示中间状态）。
而对于循环运算 $({-})^* : \mathit{TransitionFormula} \to \mathit{TransitionFormula}$，我们只需考虑在转移公式这一层面进行计算，并不用考虑循环语句本身可能有的嵌套循环结构！
换句话说，我们可以借鉴已有的各种 Loop Summarization / Acceleration 技术。&lt;/p&gt;
&lt;p&gt;在这里，我们只讨论一种基于&lt;strong&gt;区间分析&lt;/strong&gt;的循环运算实现方法（本文开头提到的参考材料中有更多的例子）。
在区间分析中，我们一般考虑形如 $\bigwedge_{x \in X} (a_x \le x \le b_x)$ 的状态公式，其中 $a_x,b_x$ 为常数。
例如，对于下面这个程序中的循环而言，$0 \le i \le 10 \wedge 0 \le j \le 20$ 是一个区间不变量，但是 $0 \le i \le 10 \wedge 0 \le j \le 10$ 并不是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;传统的基于区间的程序分析会使用 widening / narrowing 等技术来确保迭代分析可以收敛，但这会影响分析的精度。
在代数程序分析的框架中，我们则拥有更好的自由度来设计对于循环的分析：考虑循环体的转移公式为 $F(X,X&amp;rsquo;)$，那么断言“$A = \{ a_x \mid x \in X \}$ 和 $B = \{ b_x \mid x \in X \}$构成一个区间不变量”可以表述为下面的公式：
$$
\forall X, X&amp;rsquo;. \left(\left(\bigwedge_{x \in X}(a_x \le x \le b_x)\right) \wedge F(X,X&amp;rsquo;)\right) \implies \bigwedge_{x \in X} (a_x \le x&amp;rsquo; \le b_x)
$$
令 $Inv(A,B)$ 为上面这个式子。那么循环运算 $F^{*}$ 可以定义为：
$$
\forall A, B. \left( Inv(A,B) \wedge \bigwedge_{x \in X} (a_x \le x \le b_x) \right) \implies \bigwedge_{x \in X} (a_x \le x&amp;rsquo; \le b_x)
$$
这种循环运算的实现蕴含了&lt;strong&gt;所有&lt;/strong&gt;可以由循环体转移公式 $F$ 得出的区间不变量！&lt;/p&gt;
&lt;p&gt;前面我们提到，代数程序分析要求在程序语法树上进行&lt;strong&gt;结构&lt;/strong&gt;递归，那么在&lt;strong&gt;非结构&lt;/strong&gt;的程序上（例如有 &lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;continue&lt;/code&gt;），我们是否还能进行代数程序分析呢？
答案再次由 Robert Tarjan 给出：&lt;strong&gt;Yes&lt;/strong&gt;！（至于为什么用“再”可以看我&lt;a href=&#34;../introduction-to-static-resource-analysis&#34;&gt;上次的分享&lt;/a&gt;。)
Tarjan 的两篇文章 &lt;a href=&#34;https://doi.org/10.1145/322261.322273&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fast Algorithms for Solving Path Problems&lt;/a&gt; 和 &lt;a href=&#34;https://doi.org/10.1145/322261.322272&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;A Unified Approach to Path Problems&lt;/a&gt; 中提出了一种高效的基于代数的在图上解决路径问题的算法：这里的路径问题指的是图中的边上有权值，一条路径的权值为其中边权相&lt;strong&gt;乘&lt;/strong&gt;，然后我们想要计算符合某种条件的所有路径的权值&lt;strong&gt;和&lt;/strong&gt;（这里的&lt;strong&gt;乘&lt;/strong&gt;和&lt;strong&gt;和&lt;/strong&gt;都是抽象的，例如如果权值为非负数，&lt;strong&gt;乘&lt;/strong&gt;为加，&lt;strong&gt;和&lt;/strong&gt;为取最小值，那么路径问题描述的则是最短路问题）。
Tarjan 提出了一种可以计算图上两点间所有路径的集合的高效算法，其关键点在于这个（可能无穷的）路径集合可以表述为一个有限的&lt;strong&gt;正则表达式&lt;/strong&gt;，其后解路径问题就可以转化为在一个描述问题的代数结构中解释正则表达式：这与我们上文描述的三种运算（连接 $\cdot$，分支 $+$，循环 $^*$）正好是符合的！
所以，对于非结构的程序，我们可以把它表示成一个控制流图，然后通过 Tarjan 的算法计算出描述所有可能的程序执行路径的正则表达式，最后在描述程序分析的代数结构中解释该正则表达式。
例如，以下程序&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;中的所有可能路径的集合可以表述为下面的正则表达式：
$$\small
\left(\fbox{m=0} \cdot \left(\fbox{m&amp;lt;8} \cdot \fbox{n&amp;gt;=0} \cdot \fbox{m=m+1} \cdot \fbox{n=n-1}\right)^* \cdot \fbox{m&amp;gt;=8}\right)^* \cdot \fbox{m=0} \cdot \fbox{m&amp;lt;8} \cdot \fbox{n&amp;lt;0}
$$&lt;/p&gt;
&lt;p&gt;在文章的最后，我们聊一聊代数程序分析的不足。
最明显的不足在于，尽管 Compositionality 是个好性质，它也意味着我们在程序分析中丢失了&lt;strong&gt;上下文&lt;/strong&gt;信息。
一方面，由于在分析某个程序组成部分时不能依赖其上下文，我们在分析时需要追踪更多的信息（例如上文的状态转移公式代数需要同时记录 $X$ 和 $X&amp;rsquo;$）；另一方面，我们可能会由于缺乏上下文信息而对某个程序组成部分进行过于保守的分析（这取决于程序分析状态空间设计得好不好）。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Zachary Kincaid, Thomas Reps, and John Cyphert. Algebraic Program Analysis. &lt;a href=&#34;https://doi.org/10.1007/978-3-030-81685-8_3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://doi.org/10.1007/978-3-030-81685-8_3&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Zachary Kincaid and Thomas Reps. Introduction to Algebraic Program Analysis. &lt;a href=&#34;https://www.cs.wisc.edu/wpis/talks/CAV21-Algebraic-Part1-regular.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Part 1&lt;/a&gt;, &lt;a href=&#34;https://www.cs.wisc.edu/wpis/talks/CAV21-Algebraic-Part2-foundations.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Part 2&lt;/a&gt;, &lt;a href=&#34;https://www.cs.wisc.edu/wpis/talks/CAV21-Algebraic-Part3-InterproceduralAnalysis.pptx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Part 3&lt;/a&gt;, &lt;a href=&#34;https://www.cs.wisc.edu/wpis/talks/CAV21-Algebraic-Part4-termination.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Part 4&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>随便聊聊：静态资源分析</title>
      <link>https://stonebuddha.github.io/zh/post/introduction-to-static-resource-analysis/</link>
      <pubDate>Sat, 10 Sep 2022 15:32:19 +0800</pubDate>
      <guid>https://stonebuddha.github.io/zh/post/introduction-to-static-resource-analysis/</guid>
      <description>&lt;p&gt;简单地说，程序的&lt;strong&gt;资源分析&lt;/strong&gt;（Resource Analysis）指的是把该程序的资源消耗表示成一个关于程序输入的函数。
这里的&lt;strong&gt;资源&lt;/strong&gt;可以是运行时间、内存使用、能源消耗，或别的什么数值指标。
高德纳（Donald Knuth）在《计算机程序设计的艺术》（&lt;em&gt;The Art of Computer Programming&lt;/em&gt;）中就基于 MIX 汇编语言的语义讨论了一些资源分析的问题。
在计算机科学的课程中，资源分析通常以&lt;strong&gt;分析算法、数据结构的时间、空间复杂度&lt;/strong&gt;的形式出现，而这里面最常见的又通常是&lt;strong&gt;渐近分析&lt;/strong&gt;，即忽略常数、假定输入规模充分大时的复杂度，例如对长度为 $n$ 的数组进行归并排序时间复杂度为 $O(n \log n)$。
在这篇文章中，我们考虑一个稍微困难点的情况，即我们希望得到的分析结果是带有常数信息的&lt;strong&gt;非渐近&lt;/strong&gt;复杂度：从非渐近分析可以容易得出渐近分析的结果，而且前者还可以用来精细地比较渐近复杂度相同的算法、数据结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态&lt;/strong&gt;资源分析即在不实际运行程序的情况下对其进行资源分析。
Facebook 出品的 Infer 工具提供了函数级的静态运行时间分析，其宗旨是在软件开发的过程中更早地指出性能问题（比方说，在 Code Review 阶段由工具自动反馈，而不是等到后面的性能回归测试）。
下面这个例子来源于 Infer 的官方文档&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;loop&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Infer 通过静态分析对上面这个函数得出一个描述其运行时间的多项式（比如 $8|list|+16$），从而知道这个函数的时间复杂度和其输入列表的长度呈线性关系。
如果某一次代码修改把这个函数更新为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;loop&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// newly added function call
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而此处的 &lt;code&gt;foo&lt;/code&gt; 函数的时间复杂度也是与输入呈线性关系，那么 Infer 可以检测到 &lt;code&gt;loop&lt;/code&gt; 函数的复杂度从 $O(|list|)$ 增长到了 $O(|list|^2)$，并向开发者发出警报。
（如果想要更深入了解 Infer 中的资源分析，可以参考&lt;a href=&#34;https://youtu.be/-sqdJbvqeNQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这个视频&lt;/a&gt;。）&lt;/p&gt;
&lt;p&gt;笼统地说，Infer 中的资源分析可以大致理解为对循环次数进行计数，从而将资源分析问题转化为程序变量数值关系的分析；这也是很多静态资源分析（比如 SPEED&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;）背后的原理。
在这篇文章中，我们来聊另一种颇为有趣的静态资源分析：&lt;strong&gt;自动均摊资源分析&lt;/strong&gt;（Automatic Amortized Resource Analysis，AARA）。
这种方法衍生自 Robert Tarjan 在 1985 年的一篇论文&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;，文中给出了一种推导序列操作的&lt;strong&gt;最坏&lt;/strong&gt;情况资源消耗的方法。
该方法的思路可以概括为：对于很多数据结构来说，一个操作消耗的资源很大程度上是由数据结构的状态决定的，而且有可能会根据状态有很大的不同；但是比较高的资源消耗（例如重新组织整个数据结构）往往会以一种可以预测的频率出现，也就是说，这些消耗在时间轴上&lt;strong&gt;均摊&lt;/strong&gt;了。
均摊资源分析即利用了这种思想：我们可以把程序的执行看做是一个操作序列 $s_1,s_2,s_3,\cdots$，这里的每个 $s_i \in \mathrm{State}$ 都表示一个程序状态，而我们用一个函数 $cost(s_i,s_{i+1})$ 来描述资源的消耗；然后我们设计一个&lt;strong&gt;势能函数&lt;/strong&gt; $\Phi : \mathrm{State} \to \mathbb{Q}^+$ 把程序状态映射为非负数，使得对任意的 $i$，我们有
$$
\Phi(s_{i}) \ge cost(s_{i}, s_{i+1}) + \Phi(s_{i+1}),
$$
即一个状态的势能要足以支付当前程序操作的资源消耗以及下一个程序状态的势能（思考题：$cost$ 为负时意味着什么？）。
如此以来，$\Phi(s_0)$ 给出了程序的总资源消耗的一个&lt;strong&gt;上界&lt;/strong&gt;，而我们需要做的是定义一个势能函数，并证明在每个程序执行的&lt;strong&gt;局部&lt;/strong&gt;，上述表达式成立。
这意味着均摊资源分析的 Compositionality 是很好的！&lt;/p&gt;
&lt;p&gt;我们知道，类型系统的一大特点也是 Compositionality；所以，设计一个&lt;strong&gt;用于均摊资源分析的类型系统&lt;/strong&gt;是非常自然的想法。
考虑下面这段 OCaml 代码，它是连接两个列表的简单实现，而我们想要分析它递归调用的次数（这也是一种资源消耗）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ocaml&#34; data-lang=&#34;ocaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;rec&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;append&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;match&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l1&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;with&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rest&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;append&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;in&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rest&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们能够很容易地看出 &lt;code&gt;append&lt;/code&gt; 函数递归调用的次数是 $|l_1|$。
假定这个 &lt;code&gt;append&lt;/code&gt; 函数的类型为 $L(\alpha) \times L(\alpha) \to L(\alpha)$，这里的 $L$ 即表示列表类型。
均摊分析要求我们给程序状态赋予势能，在这个例子中，我们则需要把我们的势能放在 &lt;code&gt;append&lt;/code&gt; 的参数 $l_1$ 和 $l_2$ 里。
让我们给列表类型增加一个数值标注：用 $L^q(\alpha)$ 表示一个列表类型，其中的&lt;strong&gt;每个元素都携带了 $q$ 单位的势能&lt;/strong&gt;，并假定所有程序操作的资源消耗都是 $0$，除了递归调用的消耗为 $1$ 单位。
所以，&lt;code&gt;append&lt;/code&gt; 的带资源标注的类型可以写为 $L^1(\alpha) \times L^0(\alpha) \to L^0(\alpha)$：如果我们计算参数和结果之间的势能差，我们就能发现那恰好是 $|l_1|$。
但是，我们如何通过类型系统来检查这个类型是不是正确的呢？
还记得 Compositionality 吗——我们只需要对局部操作验证一下势能不等式：比如，在模式匹配时，如果 $l_1$ 非空，那么我们把它解构为 $x$ 和 $xs$，其中 $xs$ 的类型与 $l_1$ 相同，为 $L^1(\alpha)$，但是 $xs$ 的长度比 $l_1$ 少 $1$，所以这一步解构给了我们 $1$ 单位的自由势能，我们可以用它来支付紧接着的这个递归调用。
接着我们检查 $xs$ 和 $l_2$ 的类型是否符合 &lt;code&gt;append&lt;/code&gt; 的类型签名（当然！）。
最后，类型签名告诉我们 $rest$ 的类型为 $L^0(\alpha)$，所以构建最终返回结果 $x :: rest$ 也不需要往这个数据结构里面存势能了。&lt;/p&gt;
&lt;p&gt;我在&lt;a href=&#34;demo.pdf&#34;&gt;这份胶片&lt;/a&gt;里更详细地展示了这个带资源标注的类型系统。
需要特别提出的是，&lt;strong&gt;自动推导&lt;/strong&gt;这些数值标注并不困难：我们用变量来表示这些类型标注，那么类型检查就成为了生成关于这些变量的约束（通常是线性的）的过程，最后再解这些约束就好了。
在&lt;a href=&#34;https://www.raml.co/interface/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这个页面&lt;/a&gt;上你可以和一个实现了自动均摊资源分析的工具（Resource-aware ML，RaML）玩耍，其主要贡献者也在今年发表了一篇还不错的综述&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。
祝大家玩得愉快！&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://fbinfer.com/docs/checker-cost#examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://fbinfer.com/docs/checker-cost#examples&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://www.microsoft.com/en-us/research/publication/speed-precise-and-efficient-static-estimation-of-program-computational-complexity-2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.microsoft.com/en-us/research/publication/speed-precise-and-efficient-static-estimation-of-program-computational-complexity-2/&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;Robert Tarjan. Amortized Computational Complexity. &lt;a href=&#34;https://doi.org/10.1137/0606031&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://doi.org/10.1137/0606031&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;Jan Hoffmann and Steffen Jost. Two decades of automatic amortized resource analysis. &lt;a href=&#34;https://doi.org/10.1017/S0960129521000487&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://doi.org/10.1017/S0960129521000487&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Central Moment Analysis for Cost Accumulators in Probabilistic Programs</title>
      <link>https://stonebuddha.github.io/zh/publication/wanghr21a/</link>
      <pubDate>Sun, 20 Jun 2021 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/zh/publication/wanghr21a/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Sound Probabilistic Inference via Guide Types</title>
      <link>https://stonebuddha.github.io/zh/publication/wanghr21b/</link>
      <pubDate>Sun, 20 Jun 2021 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/zh/publication/wanghr21b/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Expected-Cost Analysis for Probabilistic Programs and Semantics-Level Adaption of Optional Stopping Theorems</title>
      <link>https://stonebuddha.github.io/zh/publication/wanghr21c/</link>
      <pubDate>Tue, 30 Mar 2021 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/zh/publication/wanghr21c/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Liquid Resource Types</title>
      <link>https://stonebuddha.github.io/zh/publication/knothwr20/</link>
      <pubDate>Sun, 23 Aug 2020 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/zh/publication/knothwr20/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Raising Expectations: Automating Expected Cost Analysis with Types</title>
      <link>https://stonebuddha.github.io/zh/publication/wangkh20/</link>
      <pubDate>Sun, 23 Aug 2020 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/zh/publication/wangkh20/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Resource-Guided Program Synthesis</title>
      <link>https://stonebuddha.github.io/zh/publication/knothwp19/</link>
      <pubDate>Sat, 22 Jun 2019 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/zh/publication/knothwp19/</guid>
      <description></description>
    </item>
    
    <item>
      <title>A Denotational Semantics for Low-Level Probabilistic Programs with Nondeterminism</title>
      <link>https://stonebuddha.github.io/zh/publication/wanghr19/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/zh/publication/wanghr19/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Type-Guided Worst-Case Input Generation</title>
      <link>https://stonebuddha.github.io/zh/publication/wangh19/</link>
      <pubDate>Sun, 13 Jan 2019 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/zh/publication/wangh19/</guid>
      <description></description>
    </item>
    
    <item>
      <title>PMAF: An Algebraic Framework for Static Analysis of Probabilistic Programs</title>
      <link>https://stonebuddha.github.io/zh/publication/wanghr18/</link>
      <pubDate>Wed, 20 Jun 2018 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/zh/publication/wanghr18/</guid>
      <description></description>
    </item>
    
    <item>
      <title>TiML: A Functional Language for Practical Complexity Analysis with Invariants</title>
      <link>https://stonebuddha.github.io/zh/publication/wangwc17/</link>
      <pubDate>Wed, 25 Oct 2017 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/zh/publication/wangwc17/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Conditional Dyck-CFL Reachability Analysis for Complete and Efficient Library Summarization</title>
      <link>https://stonebuddha.github.io/zh/publication/tangwx17/</link>
      <pubDate>Sat, 22 Apr 2017 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/zh/publication/tangwx17/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Resources for Prospective Students</title>
      <link>https://stonebuddha.github.io/zh/prospective-students/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/zh/prospective-students/</guid>
      <description>&lt;p&gt;&lt;strong&gt;（最后更新：2023 年 10 月 2 日）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我对编程语言的多个研究话题都很有兴趣，尤其是形式化验证、程序分析以及概率编程。
我目前的研究项目主要涉及资源安全的系统编程、可编程贝叶斯推断、量化程序分析以及面向证明的编程语言。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你想了解我目前的研究项目和方向，可以参考下方的&lt;a href=&#34;#目前的研究项目和方向&#34;&gt;列表&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;如果你想看一下我申请教职时关于&lt;strong&gt;软件中的随机性&lt;/strong&gt;的构想，可以参考我的&lt;a href=&#34;https://stonebuddha.github.io/files/research.pdf&#34; target=&#34;_blank&#34;&gt;研究陈述（英文）&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;如果你比较关心我在教学和指导学生上的经验和方法，可以参考我的&lt;a href=&#34;https://stonebuddha.github.io/files/teaching.pdf&#34; target=&#34;_blank&#34;&gt;教学陈述（英文）&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;如果你有关于我、北京大学或者程序设计语言研究室的具体问题，可以参考下面的 &lt;a href=&#34;#qa&#34;&gt;Q&amp;amp;A&lt;/a&gt; 或者发邮件给我。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;qa&#34;&gt;Q&amp;amp;A&lt;/h1&gt;
&lt;details open class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;“你招收学生吗？”&lt;/summary&gt;
  &lt;div style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
  &lt;b&gt;是的&lt;/b&gt;！
  我计划每年招一到两个博士生，也欢迎感兴趣的硕士和本科生。
  &lt;/div&gt;
&lt;/details&gt;
&lt;details open class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;
  “我需要有&lt;em&gt;特定&lt;/em&gt;的研究履历吗？我需要清楚自己要做什么&lt;em&gt;特定&lt;/em&gt;的项目吗？”
  &lt;/summary&gt;
  &lt;div style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
  简单的回答是“&lt;b&gt;不用&lt;/b&gt;”。
  有编程语言或软件工程相关的研究经验当然很好，但&lt;b&gt;不是必需的&lt;/b&gt;。
  相比于过往的经验，更重要的是你知道自己对什么感兴趣，并且有动力用四到五年的时间去探索一个领域内的各种问题。
  &lt;/div&gt;
&lt;/details&gt;
&lt;details open class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;“我可以做机器学习、操作系统、数据库等等相关的项目吗？”&lt;/summary&gt;
  &lt;div style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
  &lt;b&gt;没问题&lt;/b&gt;，这些领域与编程语言都有相关的交叉领域。
  以下是一些跨领域的研讨会，仅作参考：
  &lt;a href=&#34;https://mapsworkshop.github.io/&#34;&gt;Symposium on Machine Programming&lt;/a&gt;，
  &lt;a href=&#34;https://popl23.sigplan.org/home/lafi-2023&#34;&gt;Workshop on Languages for Inference&lt;/a&gt;，
  &lt;a href=&#34;https://plos-workshop.org/2023/&#34;&gt;Workshop on Programming Languages and Operating Systems&lt;/a&gt;，
  &lt;a href=&#34;https://sites.google.com/view/dbpl2021&#34;&gt;Symposium on Database Programming Languages&lt;/a&gt;。
  &lt;/div&gt;
&lt;/details&gt;
&lt;details open class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;“北京大学有什么优势？在那儿可以跟哪些老师合作？”&lt;/summary&gt;
  &lt;div style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
  北京大学拥有世界一流的计算机学院（&lt;a href=&#34;https://csrankings.org/#/index?all&amp;world&#34;&gt;CSRankings (2013-2023)&lt;/a&gt; 排名 14，&lt;a href=&#34;https://www.topuniversities.com/university-rankings/university-subject-rankings/2023/computer-science-information-systems&#34;&gt;QS Rankings (2023)&lt;/a&gt; 排名 19）。
  计算机学院拥有很多很厉害的老师和学生，他们的研究包括软件工程、编程语言、操作系统等诸多领域。
  以下是软件工程、编程语言领域的一些老师，按照姓氏字典序排列，仅供参考：
  &lt;a href=&#34;http://sei.pku.edu.cn/~haod&#34;&gt;郝丹&lt;/a&gt;，
  &lt;a href=&#34;https://zhenjiang888.github.io/&#34;&gt;胡振江&lt;/a&gt;，
  &lt;a href=&#34;https://taoxiease.github.io/&#34;&gt;谢涛&lt;/a&gt;，
  &lt;a href=&#34;https://xiongyingfei.github.io/&#34;&gt;熊英飞&lt;/a&gt;，
  &lt;a href=&#34;http://sei.pku.edu.cn/~zhanglu&#34;&gt;张路&lt;/a&gt;，
  &lt;a href=&#34;https://xinpl.github.io/&#34;&gt;张昕&lt;/a&gt;。
  &lt;/div&gt;
&lt;/details&gt;
&lt;details open class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;“你为什么还没有回我邮件！”&lt;/summary&gt;
  &lt;div style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
  &lt;b&gt;不好意思，如果一个星期了我都还没回，麻烦再发送一次。&lt;/b&gt;
  &lt;/div&gt;
&lt;/details&gt;
&lt;h1 id=&#34;目前的研究项目和方向&#34;&gt;目前的研究项目和方向&lt;/h1&gt;
&lt;p&gt;以下是我目前主要的研究项目（并不是一个完整的列表）。如果你有兴趣在这些项目上与我进行合作，请联系我！&lt;/p&gt;
&lt;h3 id=&#34;资源安全的系统编程&#34;&gt;资源安全的系统编程&lt;/h3&gt;
&lt;p&gt;程序的资源消耗（比如时间、内存、能源）是计算机科学中的一个重要研究对象，但是它在程序语言理论（比如形式化语义、静态分析、类型系统、程序逻辑）里往往不太受重视。
我对与资源消耗分析相关的项目都很有兴趣，包括程序验证（比如验证现有语言上的现有代码的时间复杂度符合规约）和语言设计（比如使得资源分析更容易、更精确的语言特性）。&lt;/p&gt;
&lt;p&gt;在系统编程中，资源消耗分析正变得越来越重要。
编程语言 Rust 的成功说明了现代系统编程需要编程语言提供更强的静态安全保障，比如内存安全和线程安全。
当然，很多现有语言是能够提供多种安全保障的，但往往是通过一些运行时机制（比如垃圾回收），而这些机制会有一定的运行时开销，影响程序性能，这在系统软件中常常不够令人满意。
Rust 语言设计了一个保障内存安全的类型系统，降低了运行时的内存管理开销，从而提高了软件性能。
&lt;strong&gt;不过，系统软件的性能并不仅仅与内存管理有关。&lt;/strong&gt;
我想要提出一个&lt;strong&gt;资源安全编程&lt;/strong&gt;的范式，该范式不但能在静态检查中验证程序的资源消耗符合开发者的预期，而且能够保障程序中没有与资源消耗相关的安全缺陷，比如算法复杂度攻击漏洞和侧信道攻击漏洞。
以下为一些关于资源安全系统编程的中到长期项目：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rust 语言上的资源分析&lt;/strong&gt;：Rust 中的精确内存模型是否可以帮助提高资源分析的精度和效率？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并发程序的资源分析&lt;/strong&gt;：Rust 已经可以静态检查一些线程安全问题（如数据竞争），但还存在很多局限，比如不能静态检查是否存在死锁。
我们是否可以在系统编程的类型系统中融入精确的并发模型，并为之设计资源分析的方法？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目标代码资源分析&lt;/strong&gt;：如何保证编译后的目标代码仍然符合在源代码上分析出的资源消耗情况？更进一步地，如何分析目标代码的细粒度资源消耗，比如时钟周期数？
在这个粒度上，我们需要考虑硬件特性，比如缓存、流水线、分支预测等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;挖掘资源消耗相关安全问题&lt;/strong&gt;：我们是否可以利用资源消耗分析来挖掘算法复杂度攻击和/或侧信道攻击安全漏洞？
更进一步地，如果发现了潜在漏洞，我们是否可以自动合成一个攻击方案来实际触发该漏洞，以证明漏洞确实存在？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;目前我比较倾向尝试的技术路线是自动均摊资源分析（Automatic Amortized Resource Analysis，AARA&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;）。
当然，我也愿意尝试其它方法，比如递推关系求解（Recurrence Solving）、带大小类型（Sized Types）、阶函数（Ranking Functions）、符号资源分析（Symbolic Resource Analysis）等，毕竟实践是检验真理的唯一标准。&lt;/p&gt;
&lt;h3 id=&#34;可编程贝叶斯推断&#34;&gt;可编程贝叶斯推断&lt;/h3&gt;
&lt;p&gt;与频率学派的方法（如一般意义上的深度学习）认为模型是一个未知的假设，贝叶斯学习侧重分析能生成观测到的数据的假设的概率分布，从而自然地能对学习到的模型的不确定性进行分析。
贝叶斯学习也有容易融入领域知识、在未知数据上有较好的泛化能力等优点。
概率编程语言（Probabilistic Programming Language，PPL）如 &lt;a href=&#34;https://mc-stan.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Stan&lt;/a&gt; 和 &lt;a href=&#34;http://pyro.ai/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pyro&lt;/a&gt; 等通过自动化贝叶斯推断使得应用贝叶斯学习更加容易。
这些语言往往通过语言设计来隔离概率模型迭代和贝叶斯推断，并在推断引擎中提供若干种不同的推断算法。&lt;/p&gt;
&lt;p&gt;贝叶斯学习的一个主要不足是贝叶斯推断的计算复杂性很高，而且最先进的推断算法也不能在所有概率模型上都有令人满意的效果。
为了使贝叶斯推断在更多的概率模型和更大的数据规模上能够起作用，一些 PPL 减弱了建模和推断之间的隔离，允许用户对一些特性的贝叶斯推断算法进行定制，这种模式被称为&lt;strong&gt;可编程推断&lt;/strong&gt;&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。
然而，用户定制推断算法时是比较容易出错的，这些错误会影响贝叶斯推断的收敛性和正确性，甚至很多时候这些错误在开发和模型迭代的过程中难以被察觉。&lt;/p&gt;
&lt;p&gt;为了平衡可编程贝叶斯推断的可靠性和灵活性，我希望在概率编程中应用编程语言技术，比如类型系统、静态分析、程序合成等。
通过新的编程抽象和类型系统，我们可以保证推断的可靠性（包括收敛性和正确性），而通过静态分析和程序合成，我们可以为用户提供辅助来自动化推断自定义的过程，从而提高开发效率。
我们的 &lt;a href=&#34;https://stonebuddha.github.io/zh/publication/wanghr21b&#34; target=&#34;_blank&#34;&gt;PLDI 论文&lt;/a&gt;可以看作这个研究项目的第一步。&lt;/p&gt;
&lt;h3 id=&#34;量化程序分析&#34;&gt;量化程序分析&lt;/h3&gt;
&lt;p&gt;程序中的随机性可以表现为两方面：外部随机性（比如运行环境中的不确定性）和内部随机性（比如随机化算法）。
正如 Kleene 代数可作为非概率程序的代数程序分析的理论基础&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;，我希望建立一个适用于概率程序的代数程序分析的理论框架。
为此，我们需要构建一个概率程序的代数语义框架，并以此为基础设计一个通用的概率程序的程序分析求解算法。&lt;/p&gt;
&lt;p&gt;非概率程序和概率程序间的一个本质不同是非概率程序的一个运行可以看作&lt;strong&gt;一条链&lt;/strong&gt;，但是概率程序的一个运行需要看作&lt;strong&gt;一棵树&lt;/strong&gt;。
为了说明这一点，我们考虑一个同时支持概率和非确定性的程序模型。
在该模型下，一个非概率程序对应一个可能的运行链的集合，但是一个概率程序需要对应&lt;strong&gt;一个概率分布的集合&lt;/strong&gt;，其中的每个概率分布对应一个运行树，树上的每条从根出发的路径则对应程序中的一条具体的运行链。
我们在 &lt;a href=&#34;https://stonebuddha.github.io/zh/publication/wanghr19&#34; target=&#34;_blank&#34;&gt;MFPS 论文&lt;/a&gt;中基于&lt;strong&gt;超图&lt;/strong&gt;（Hyper-Graphs）给出了上述想法的形式化表示。&lt;/p&gt;
&lt;p&gt;抽象解释是一个表达和求解程序分析的强大通用框架。在这个框架中，人们已经设计了多种通用求解策略和收敛技术，比如 Chaotic Iteration、Widening、Narrowing 等。
&lt;strong&gt;但是，这些基于迭代的求解算法与概率程序本身的量化特质不太匹配。&lt;/strong&gt;
假设我们想分析概率循环“$\mathbf{while}~(\mathbf{prob}(3/4))~\{ x = x + 1; \}$”。
变量 $x$ 的期望变化量可以看作是方程 $r = f(r) \equiv (1/4) \cdot 0+(3/4) \cdot (r+1)$ 的最小的解，很容易看出这个解是 $r=3$。
但是，一个基于迭代的求解策略大概会通过一系列近似来逼近 $r$：$\{ f^i(0) \}_{i \in \mathbb{N}}$，该序列并不能在任何有限的迭代次数内收敛。
在数值分析领域中，牛顿法往往是更适用于这种量化特性的方法，所以我希望能够将&lt;strong&gt;牛顿程序分析&lt;/strong&gt;&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;技术迁移到概率程序的程序分析上。&lt;/p&gt;
&lt;p&gt;更进一步地，这个概率程序的代数分析框架从原则上也应该适用于其它的量化性质，比如&lt;strong&gt;资源消耗&lt;/strong&gt;。
我很好奇这一观察是否可以导出一个更通用的量化程序分析框架。
最近的一篇论文&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;还提出了 &lt;strong&gt;Weighted Programming&lt;/strong&gt; 的概念，进一步从量化数值性质推广到符合某些代数结构的性质。
作为这个通用量化程序分析框架的应用，我们可以在概率分析和资源分析两个社区间进行技术迁移，比如最大后验估计（MAP）跟最坏情况分析（WCA）的数学形式很相近，我希望研究是否可以基于此关系设计新的统计资源分析方法。&lt;/p&gt;
&lt;!-- ### Proof-Oriented Programming Languages --&gt;
&lt;h1 id=&#34;其它项目&#34;&gt;其它项目&lt;/h1&gt;
&lt;p&gt;我对新的方向永远持欢迎的态度，包括跨领域的方向。
以下是一些我有兴趣探索的研究想法，它们通常是短到中期的研究项目。
注意，这个列表并不完整，而且很多想法并不成熟（我甚至预期其中的相当一部分不太能做得出来）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（以下内容为英文）&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;静态分析&#34;&gt;静态分析&lt;/h3&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Library Summarization via Tensor Products&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Library summarization is an effective way to accelerate the
analysis of client code. However, information about the client is unknown
at the library summarization, preventing complete summarization of the library.
A state-of-the-art approach is &lt;a href=&#34;https://stonebuddha.github.io/publication/tangwx17&#34; target=&#34;_blank&#34;&gt;Conditional Dyck-CFL Reachability Analysis (ConCRA)&lt;/a&gt;,
which targets graph-reachability-like static analyses and uses hypothetical summaries.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: Lal et al.&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt; proposed a tensor-product principle: Tensor products
with an appropriate detensor operation allow computations to be rearranged in
certain ways; for example, they can be used to delay a multiplication in a chain
of multiplications. This principle may allow us to generalize, in the summarization framework,
Dyck-CFL-reachability-based analyses to algebraic semiring-based analysis.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: The library summarization problem can be generalized to partially solving
an equation system for a static analysis. Any thoughts on partial evaluation?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;NPA-TP for Non-idempotent Semirings&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Esparza et al.&lt;sup id=&#34;fnref1:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; generalized Newton&amp;rsquo;s method to a method for finding
fixed-points of systems of equations over semirings, leading to a new algorithm
to solve interprocedural dataflow analysis.
Reps et al.&lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt; developed NPA-TP, which extended Esparza&amp;rsquo;s framework with an improved
algorithm for solving linear-context-free-language (LCFL) sub-problems.
However, NPA-TP assumes the underlying abstract domain admits an idempotent semiring;
such an assumption rules out interesting analysis domains, especially for numerical
properties, e.g., the reaching probability.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: Esparza&amp;rsquo;s original framework does support non-idempotent semirings,
so it would be a good starting point. The NPA-TP framework features tensor products
to solve LCFL sub-problems, and from the perspective of algebras, the principle of
tensor products does not require idempotence.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: Some recent work shows that quantum computation also needs
non-idempotent semirings. Can the idea of NPA-TP be generalized to analyze
quantum programs?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Complicated Probability Manipulation&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: In many programs, the manipulation of probability is very complicated
and even manual analysis of their correctness is difficult. Consider the problem below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;prob&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We want to verify that at the end of the loop, the probability of the event $x \ge \frac{1}{2}$
is exactly $p$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: &lt;a href=&#34;https://en.wikipedia.org/wiki/Probability-generating_function&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Probability-generating functions&lt;/a&gt; provide a succinct
way to describe probability distributions of discrete random variables.
We might try to derive the probability-generating function of a probabilistic program to
reason about the resulting distribution of the program.
A recent paper&lt;sup id=&#34;fnref:8&#34;&gt;&lt;a href=&#34;#fn:8&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;8&lt;/a&gt;&lt;/sup&gt; is on this direction.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: There is a connection between derivatives of the probability-generating function of
a random variable $X$ and the moments of $X$. Can we use the fact to perform moment analysis?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Fine-grained Heap Abstraction via Regular Patterns&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Static analysis of heap-manipulation programs often involves
heap sensitivity. In the simplest case, all memory allocations with the same
program location are treated as a single allocation (thus in a context-insensitive way).
Advanced techniques include three-value-logic for shape analysis, $k$-CFA, $m$-CFA&lt;sup id=&#34;fnref:9&#34;&gt;&lt;a href=&#34;#fn:9&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;9&lt;/a&gt;&lt;/sup&gt;, etc.
However, they seem insufficient when we want to analyze recursive programs.
(Imagine that in functional programming, iterating over a list is usually implemented as a
recursive function.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: We can treat the set of all call-strings as a language, then
different strategies for handling sensitivity are essentially different ways of
defining equivalence classes on the language. A presumably good proposal is to use
regular patterns to classify equivalence classes.
For example, $(ff)^*$ indicates calling a function $f$ for an even number of times,
$f(ff)^*$ for an odd number.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: In fact, this approach should generalize to all sensitivities that
use call strings. Is it meaningful to develop a general framework with regular-pattern-sensitivity?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;h3 id=&#34;形式化语义&#34;&gt;形式化语义&lt;/h3&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Combination of Continuous Distributions and Nondeterminism-first&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: &lt;a href=&#34;https://stonebuddha.github.io/publication/wanghr19&#34; target=&#34;_blank&#34;&gt;Nondeterminism-first&lt;/a&gt; means that we resolve nondeterminism prior to
program inputs when defining denotational semantics. For example, suppose that a
deterministic function has the signature $A \to B$, then a standard resolution of
nondeterminism gives us $A \to \wp(B)$, but nondeterminism-first suggests $\wp(A \to B)$.
Nondeterminism-first can be useful for e.g., compile-time nondeterminism.
A recent study proposed a denotational semantics for probabilistic programs
that combines discrete distributions (on a countable state space) and nondeterminism-first.
However, it remains open if the semantics can be extended to support continuous distributions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: In fact, I do not have any ideas yet.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: What about a computational theory for such a combination?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Combination of Probability and Message-passing Concurrency&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: The common treatment of a probabilistic flip in the semantics
is to &amp;ldquo;split&amp;rdquo; the current program configuration into two, one for the &amp;ldquo;world&amp;rdquo; where
the flip shows heads and the other for tails. When we need to deal with multiple
concurrent processes, such a treatment means a local flip in a process results in
duplicating all other processes. Such a non-local (thus non-compositional) behavior has been shown to be
problematic for proving soundness of formal methods (e.g., type systems, which are usually compositional).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: The result of a probabilistic flip should remain as local as possible.
We have recently developed &lt;a href=&#34;https://stonebuddha.github.io/publication/daswh20&#34; target=&#34;_blank&#34;&gt;an operational semantics with the desirable locality&lt;/a&gt;, but I feel that
a more algebraic representation is better. For example, we might want to rearrange
the operational semantics to reduction rules and congruence rules. Furthermore, we
should prove an equivalence result to the ordinary probabilistic semantics (e.g., Markov chains).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: I can always imagine that adding nondeterminism causes a lot of troubles.&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Building a Framework for Nondeterminism-as-refinement&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Nondeterminism is often referred to as the basis of
abstraction and refinement in the setting of stepwise developement&lt;sup id=&#34;fnref:10&#34;&gt;&lt;a href=&#34;#fn:10&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;10&lt;/a&gt;&lt;/sup&gt;.
However, such a pattern has not been popular in modern programming languages.
What is the main obstable for developing such a framework? Also, people have
developed many kinds of semantics for nondeterminism. Which semantics should be the
most suitable one for refinement-based programming and reasoning?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: I guess this has something to do with relational Hoare Logics&lt;sup id=&#34;fnref:11&#34;&gt;&lt;a href=&#34;#fn:11&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;11&lt;/a&gt;&lt;/sup&gt;.
At least they provide a way to use nondeterminism in a formal framework of proving
program properties.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: How to devise a language design for it?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;h3 id=&#34;类型系统&#34;&gt;类型系统&lt;/h3&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Safe Interaction between Typed Domain Specific Languages&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Consider we have a typed programming language that is suitable for developing
embedded Domain Specific Languages (eDSLs).
Every eDSL can directly use the base type system from the host language, but it can
also have its own advanced domain-specific type system.
Languages such as &lt;a href=&#34;https://okmij.org/ftp/ML/MetaOCaml.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MetaOCaml&lt;/a&gt; have already supported
such a mechanism, but the interaction between the host language and the eDSL,
or maybe even between different eDSLs, is not very convenient yet.
It would be nice to have a simple and safe interaction scheme among eDSLs on
a same host language.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: In fact, I do not have any ideas yet.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: What else should we have for such a flexible eDSL framework? For example,
we might want to consider multi-stage compilation, debugger, mixed paradigm, etc.&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Lightweight Shape Check for Array Programming&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Array programming (or tensor programming) is pervasive nowadays because of machine learning.
Many machine-learning frameworks lack the ability to statically check tensor shapes are always consistent
during program execution. Approaches based on dependent/refinement/indexed types all seem too heavy to
become practical.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: In many (really?) cases, when the input of an array program is fixed,
the shapes of all intermediate arrays are also fixed. So we can perform a static shape check
after the input is given, but before we execute the program, by propagating the concrete shape information
from the given input.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: Is it possible to automatically learn the shape-related effects of library functions (e.g., &lt;code&gt;broadcast_tensor&lt;/code&gt;)?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Integration of Refinement Types and Separation Logic&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Recently, people have developed verification systems, e.g., CN&lt;sup id=&#34;fnref:12&#34;&gt;&lt;a href=&#34;#fn:12&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;12&lt;/a&gt;&lt;/sup&gt; and RefinedC&lt;sup id=&#34;fnref:13&#34;&gt;&lt;a href=&#34;#fn:13&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;13&lt;/a&gt;&lt;/sup&gt;,
which integrate refinement types and separtion logic to reason about low-level
programs. In those systems, refinements seem to still encode purely functional
properties (really?). How about enabling type refinements to be separation-logic
propositions? To that end, such refined types are not structural any more and
we need to work with substructural refinemend types. Does the integration make sense?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: It seems that we can start from linear refinement types.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: Linear typing and separation logic share a lot of similarities.
Are both rooted back in linear logic? If not, what is the fundamental difference?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Liquid-type-style Dijkstra Monads&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Dijkstra monads&lt;sup id=&#34;fnref:14&#34;&gt;&lt;a href=&#34;#fn:14&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;14&lt;/a&gt;&lt;/sup&gt; were originally proposed to automate
the verification-condition-generation (VCG) routine for analyzing effectful higher-order
programs. They later form the basis of F*, a proof-oriented programming language&lt;sup id=&#34;fnref:15&#34;&gt;&lt;a href=&#34;#fn:15&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;15&lt;/a&gt;&lt;/sup&gt;.
One feature of F* is that it supports proof-irrelevant refinement types.
Liquid types&lt;sup id=&#34;fnref:16&#34;&gt;&lt;a href=&#34;#fn:16&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;16&lt;/a&gt;&lt;/sup&gt; provide another method of balancing between automatic
type inference and dependent typing.
One main idea of liquid types is to separately design a language for specification.
Can we combine Dijkstra monads and liquid types? What are the benefits&amp;mdash;if there are&amp;mdash;to do this?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: So the system is basically a comination of liquid-style language design
and an F*-style type inference.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: Dijkstra monads support multi-monadic effects in a systematic way.
This means we might have a method to extend our &lt;a href=&#34;https://stonebuddha.github.io/publication/knothwr20&#34; target=&#34;_blank&#34;&gt;ICFP paper&lt;/a&gt;
to include the value interpretation as in the language itself.&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;h3 id=&#34;资源分析&#34;&gt;资源分析&lt;/h3&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Fraction Bounds for Expected Cost Analysis&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Most of current resource-analysis techniques derive linear, polynomial,
or exponential bounds. However, when analyzing probabilistic programs, we often
encounter bounds that involve fractions. For example, the simple loop &lt;code&gt;while (prob(p)) tick(1);&lt;/code&gt;
has an expected cost of $\frac{p}{1-p}$, where $p$ is a program variable that denotes
a non-trivial probability.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: In many cases, a fraction bound can be expressed as a polynomial
over another polynomial. So it should be possible to extend current template-based
resource-analysis techniques (e.g., AARA) that derive polynomial bounds, by using
a template for the denominator to reduce fraction-bound inference to polynomial-bound
inference.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: A random thought: how can we apply such resource-analysis technique
to Bayesian inference (like a recent paper by Beutner et al.&lt;sup id=&#34;fnref:17&#34;&gt;&lt;a href=&#34;#fn:17&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;17&lt;/a&gt;&lt;/sup&gt;)?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;AARA for Probabilistic Functional Programs with Non-monotone Resources&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Our &lt;a href=&#34;https://stonebuddha.github.io/publication/wangkh20&#34; target=&#34;_blank&#34;&gt;ICFP paper&lt;/a&gt; presents
an extension of AARA that infers upper bounds on the expected cost of probabilistic functional
programs with monotone resources (such as time). In general, combining probability
and non-monotone resources (such as memory) is unreasonably complex&lt;sup id=&#34;fnref:18&#34;&gt;&lt;a href=&#34;#fn:18&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;18&lt;/a&gt;&lt;/sup&gt;. Applying optional stopping
theorems, people have successfully developed techniques for analyzing arithmetic programs.
It would be interesting to see if the whole methodology applies to functional programming,
where we have inductive data structures (that can hold potential) instead of numbers.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: One version of optional stopping theorems states that the expected change
in one evaluation step should be &amp;ldquo;bounded.&amp;rdquo; This should intuitively hold for
functional programming (I mean, in most cases) because one step should change the
size of a data structure by at most one (consider the case of &lt;code&gt;cons&lt;/code&gt;).
By constructing a suitable Markov chain, we might be able to reason about
probabilistic functional programs with non-monotone resources.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: Optional stopping theorems always talk about &amp;ldquo;expected change&amp;rdquo;
and &amp;ldquo;expected termination time.&amp;rdquo; Why them?!&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Newtonian Resource Analysis&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Apply the Newtonian Program Analysis (NPA) framework&lt;sup id=&#34;fnref2:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; and its extension&lt;sup id=&#34;fnref1:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;
to carray out resource analysis.
Existing work has shown the possibility to perform recurrence-based analysis&lt;sup id=&#34;fnref:19&#34;&gt;&lt;a href=&#34;#fn:19&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;19&lt;/a&gt;&lt;/sup&gt;.
How about other kinds of resource analysis, like AARA?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: Because amortized analysis is naturally two-vocabulary, it seems possible
to recast AARA as a two-vocabulary abstract domain. The gap is that AARA is constraint-based,
which differs from the general NPA framework.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: NPA basically provides a framework for analyzing non-linear-recursive
programs by iteratively analyzing linear-recursive programs. Can we combine this idea
to iteratively use AARA to solve linear recursion?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;h3 id=&#34;概率编程&#34;&gt;概率编程&lt;/h3&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Domain-specific Procedural Design&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: &lt;a href=&#34;https://dritchie.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Daniel Ritchie&lt;/a&gt; suggested generative
probabilistic programming for procedural modeling and design (the use of random programs
to generate visual content with respect to aesthetic or functional constraints).
Such an approach has been rediscovered in several individual developments, such as
Scenic&lt;sup id=&#34;fnref:20&#34;&gt;&lt;a href=&#34;#fn:20&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;20&lt;/a&gt;&lt;/sup&gt; and Picture&lt;sup id=&#34;fnref:21&#34;&gt;&lt;a href=&#34;#fn:21&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;21&lt;/a&gt;&lt;/sup&gt;. So instead of separate developments,
we want to develop a framework to ease such domain-specific procedural design.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: This has something to do with the eDSL framework.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: It might be interesting to see how such &lt;strong&gt;static&lt;/strong&gt; procedural design
evolves to &lt;strong&gt;dynamic&lt;/strong&gt; procedural design (e.g., synthesis of an environment).
Another direction is interactive refinement (e.g., incorporating feedbacks from users)
of the generated designs.&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Language Design for Sound Involutive MCMC&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: A recent paper by Cusumano-Towner et al.&lt;sup id=&#34;fnref:22&#34;&gt;&lt;a href=&#34;#fn:22&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;22&lt;/a&gt;&lt;/sup&gt; studies
how to ease the burden of implementing involutive MCMC by combining probabilistic
programming and differentiable programming. It still remains a challenge (emm, you have to double check)
to statically verify the correctness of a concrete implementation in their framework.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: I would try to combine type systems for sound programmable inference
and sound differentiable programming.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: I am thinking of &lt;em&gt;The Next XXX MCMC Algorithms&lt;/em&gt;.&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Quantum Probability and Bayesian Inference&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Quantum physics uses a form of complex probability. People have been
thinking of it as a serious probability theory (see &lt;a href=&#34;https://arxiv.org/abs/hep-th/9307019&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_Bayesianism&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this&lt;/a&gt;).
There are even quantum analogs of Bayesian inference (&lt;a href=&#34;https://link.springer.com/chapter/10.1007/978-3-642-00834-4_5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;one&lt;/a&gt; and &lt;a href=&#34;https://arxiv.org/abs/2006.02256&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;the other&lt;/a&gt;). Does it make sense to incorporate some of those ideas in current probabilistic programming systems?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: I still have to learn quantum physics (emm, not really).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: Some people are trying to add quantum features
to standard Bayesian models (check out &lt;a href=&#34;https://www.informatyka.agh.edu.pl/media/uploads/qis_presentation12.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this&lt;/a&gt;).&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;h3 id=&#34;程序合成&#34;&gt;程序合成&lt;/h3&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Interface Synthesis for Database Tables&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: One central function of low-code programming platforms is to
automatically generate usable interface for manipulating database tables.
In an application, the developers might want to customize a specific way to
organize the interface, and they want to reuse the customization across the
application.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: The customization can be thought as a functor that takes a
database-table module as its input and outputs an inference module for that table.
For low-code programming, it would be useful to have a mechanism where
the developers customize a table interactively and the platform automatically
synthesize the code of the customization functor.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: Low-code programming involves many UI-related customization.
Is there a more general principle? For example, it might be interesting to
investigate &lt;a href=&#34;https://www.cs.cmu.edu/~NatProg/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Natural Programming&lt;/a&gt;.&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Resource-guided Synthesis and Implicit Computational Complexity&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Recently, resource-guided synthesis and algorithm synthesis have
received considerable attention&lt;sup id=&#34;fnref:23&#34;&gt;&lt;a href=&#34;#fn:23&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;23&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:24&#34;&gt;&lt;a href=&#34;#fn:24&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;24&lt;/a&gt;&lt;/sup&gt;.
We also had published a related &lt;a href=&#34;https://stonebuddha.github.io/publication/knothwp19&#34; target=&#34;_blank&#34;&gt;PLDI paper&lt;/a&gt;.
Those approaches can be categorized into two sorts: one develops a complex
type system of program logic to enforce resource guarantees, the other proposes
algorithmic templates that ensure resource guarantees.
The latter is somewhat related to &lt;a href=&#34;https://en.wikipedia.org/wiki/Implicit_computational_complexity&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Implicit Computational Complexity&lt;/a&gt; (ICC),
which characterizes algorithms by constraints on the way in which they are constructed.
In other words, an ICC research usually provides a non-standard programming language,
in which every legal program is guaranteed to have certain complexity.
Can we generalize the template-based approach to ICC-based approach?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: A starting point could be non-size-increasing computaion&lt;sup id=&#34;fnref:25&#34;&gt;&lt;a href=&#34;#fn:25&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;25&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: ICC seems to be not so fine-grained, e.g., usually researchers
focus on whether the complexity is polynomial or not. How to make them finer-grained?
For example, would it be possible to develop an ICC class for $O(n \log n)$ algorithms?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;h3 id=&#34;程序验证&#34;&gt;程序验证&lt;/h3&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Verifying Time/Memory Complexities in VST&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: &lt;a href=&#34;https://vst.cs.princeton.edu/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Verified Software Toolchain&lt;/a&gt; (VST) is a set of verified tools that formally verify the
functional correctness of C programs using Hoare logic and separation logic.
I wonder if it is also convenient to verify resource-usage properties of C programs,
like their time or memory complexities.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: It has been shown that separation logic naturally supports
resource verification based on time credits&lt;sup id=&#34;fnref:26&#34;&gt;&lt;a href=&#34;#fn:26&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;26&lt;/a&gt;&lt;/sup&gt;. So conceptually it should
be possible to have that in VST.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: Can we develop some general reasoning libraries for resource
verification?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Backward Proving in Coq&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Coq proofs are organized in a forward, tactic-based manner, which is
not very readable. In contrast, Isabelle (and some other theorem provers) provides
a backward mode, where the intermediate goals are stated explicitly, so that improves
readability. Is it possible to use a backward pattern in Coq proofs? If not, would
it be possible to have a backward-proof DSL that can be translated to Coq?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: Isabelle&amp;rsquo;s &lt;a href=&#34;https://isabelle.in.tum.de/Isar/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Isar&lt;/a&gt; might be a good starting point.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: What is the best proof interface for system programmers?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Jan Hoffmann and Steffen Jost. Two Decades of Automatic Amortized Resource Analysis. &lt;em&gt;Math. Struct. Comput. Sci.&lt;/em&gt; (2022). &lt;a href=&#34;https://doi.org/10.1017/S0960129521000487&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Vikash K. Mansinghka, Ulrich Schaechtle, Shivam Handa, Alexey Radul, Yutian Chen, and Martin Rinard.
Probabilistic Programming with Programmable Inference. &lt;em&gt;Prog. Lang. Design and Impl.&lt;/em&gt; (2018). &lt;a href=&#34;https://doi.org/10.1145/3192366.3192409&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;Zachary Kincaid, Thomas Reps, and John Cyphert. Algebraic Program Analysis. &lt;a href=&#34;https://doi.org/10.1007/978-3-030-81685-8_3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;Javier Esparza, Stefan Kiefer, and Michael Luttenberger. Newtonian Program Analysis. &lt;em&gt;J. ACM&lt;/em&gt; (2010). &lt;a href=&#34;https://doi.org/10.1145/1857914.1857917&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref1:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref2:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;
&lt;p&gt;Kevin Batz, Adrian Gallus, Benjamin Lucien Kaminski, Joost-Pieter Katoen, and Tobias Winkler. Weighted Programming: A Programming Paradigm for Specifying Mathematical Models. &lt;em&gt;Object-Oriented Prog., Syst., Lang., and Applications&lt;/em&gt; (2022). &lt;a href=&#34;https://doi.org/10.1145/3527310&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34;&gt;
&lt;p&gt;Akash Lal, Tayssir Touili, Nicholas Kidd, and Thomas Reps. Interprocedural Analysis of Concurrent Programs Under a Context Bound. &lt;em&gt;Tools and Algor. for the Constr. and Anal. of Syst.&lt;/em&gt; (2008). &lt;a href=&#34;https://doi.org/10.1007/978-3-540-78800-3_20&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34;&gt;
&lt;p&gt;Thomas Reps, Emma Turetsky, and  Prathmesh Prabhu. Newtonian Program Analysis via Tensor Product. &lt;em&gt;Princ. of Prog. Lang.&lt;/em&gt; (2016). &lt;a href=&#34;https://doi.org/10.1145/2837614.2837659&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref1:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:8&#34;&gt;
&lt;p&gt;Mingshuai Chen, Joost-Pieter Katoen, Lutz Klinkenberg, and Tobias Winkler. Does a Program Yield the Right Distribution?. &lt;em&gt;Computer Aided Verif.&lt;/em&gt; (2022). &lt;a href=&#34;https://doi.org/10.1007/978-3-031-13185-1_5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:8&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:9&#34;&gt;
&lt;p&gt;Matthew Might, Yannis Smaragdakis, and David Van Horn. Resolving and Exploiting the $k$-CFA Paradox: Illuminating Functional vs. Object-Oriented Program Analysis. &lt;em&gt;Prog. Lang. Design and Impl.&lt;/em&gt; (2010). &lt;a href=&#34;https://doi.org/10.1145/1806596.1806631&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:9&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:10&#34;&gt;
&lt;p&gt;Edsger W. Dijkstra. A Discipline of Programming. &lt;em&gt;Prentice Hall PTR&lt;/em&gt; (1997). &lt;a href=&#34;https://dl.acm.org/doi/book/10.5555/550359&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:10&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:11&#34;&gt;
&lt;p&gt;Nick Benton. Simple Relational Correctness Proofs for Static Analyses and Program Transformations. &lt;em&gt;Princ. of Prog. Lang.&lt;/em&gt; (2004). &lt;a href=&#34;https://doi.org/10.1145/982962.964003&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:11&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:12&#34;&gt;
&lt;p&gt;Christopher Pulte, Dhruv C. Makwana, Thomas Sewell, Kayvan Memarian, Peter Sewell, and Neel Krishnaswami. CN: Verifying Systems C Code with Separation-Logic Refinement Types. &lt;em&gt;Princ. of Prog. Lang.&lt;/em&gt; (2023). &lt;a href=&#34;https://doi.org/10.1145/3571194&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:12&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:13&#34;&gt;
&lt;p&gt;Michael Sammler, Rodolphe Lepigre, Robbert Krebbers, Kayvan Memarian, Derek Dreyer, and Deepak Garg. RefinedC: Automating the Foundational Verification of C Code with Refined Ownership Types. &lt;em&gt;Prog. Lang. Design and Impl.&lt;/em&gt; (2021). &lt;a href=&#34;https://doi.org/10.1145/3453483.3454036&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:13&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:14&#34;&gt;
&lt;p&gt;Nikhil Swamy, Joel Weinberger, Cole Schlesinger, Juan Chen, and Benjamin Livshits. Verifying Higher-order Programs with the Dijkstra Monad. &lt;em&gt;Prog. Lang. Design and Impl.&lt;/em&gt; (2013). &lt;a href=&#34;https://doi.org/10.1145/2491956.2491978&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:14&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:15&#34;&gt;
&lt;p&gt;Nikhil Swamy, Cătălin Hriţcu, Chantal Keller, Aseem Rastogi, Antoine Delignat-Lavaud, Simon Forest, Karthikeyan Bhargavan, Cédric Fournet, Pierre-Yves Strub, Markulf Kohlweiss, Jean-Karim Zinzindohoue, and Santiago Zanella-Béguelin. Dependent Types and Multi-monadic Effects in F*. &lt;em&gt;Princ. of Prog. Lang.&lt;/em&gt; (2016). &lt;a href=&#34;https://doi.org/10.1145/2837614.2837655&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:15&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:16&#34;&gt;
&lt;p&gt;Patrick M. Rondon, Ming Kawaguci, and Ranjit Jhala. Liquid Types. &lt;em&gt;Prog. Lang. Design. and Impl.&lt;/em&gt; (2008). &lt;a href=&#34;https://doi.org/10.1145/1379022.1375602&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:16&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:17&#34;&gt;
&lt;p&gt;Raven Beutner, Luke Ong, and Fabian Zaiser. Guaranteed Bounds for Posterior Inference in Universal Probabilistic Programming. &lt;em&gt;Prog. Lang. Design and Impl.&lt;/em&gt; (2022). &lt;a href=&#34;https://doi.org/10.1145/3519939.3523721&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:17&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:18&#34;&gt;
&lt;p&gt;Marcel Hark, Benjamin Lucien Kaminski, Jürgen Giesl, and Joost-Pieter Katoen. Aiming Low Is Harder: Induction for Lower Bounds in Probabilistic Program Verification. &lt;em&gt;Princ. of Prog. Lang.&lt;/em&gt; (2020). &lt;a href=&#34;https://doi.org/10.1145/3371105&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:18&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:19&#34;&gt;
&lt;p&gt;Zachary Kincaid, Jason Breck, Ashkan Forouhi Boroujeni, and Thomas Reps. Compositional Recurrence Analysis Revisited. &lt;em&gt;Prog. Lang. Design and Impl.&lt;/em&gt; (2017). &lt;a href=&#34;https://doi.org/10.1145/3062341.3062373&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:19&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:20&#34;&gt;
&lt;p&gt;Daniel J. Fremont, Tommaso Dreossi, Shromona Ghosh, Xiangyu Yue, Alberto L. Sangiovanni-Vincentelli, and Sanjit A. Seshia. Scenic: A Language for Scenario Specification and Scene Generation. &lt;em&gt;Prog. Lang. Design and Impl.&lt;/em&gt; (2019). &lt;a href=&#34;https://doi.org/10.1145/3314221.3314633&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:20&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:21&#34;&gt;
&lt;p&gt;Tejas D. Kulkarni, Pushmeet Kohli, Joshua B. Tenenbaum, and Vikash Mansinghka. Picture: A Probabilistic Programming Language for Scene Perception. &lt;em&gt;Comp. Vision and Pattern Recognition&lt;/em&gt; (2015). &lt;a href=&#34;https://doi.org/10.1109/CVPR.2015.7299068&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:21&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:22&#34;&gt;
&lt;p&gt;Marco Cusumano-Towner, Alexander K. Lew, and Vikash K. Mansinghka. Automating Involutive MCMC using Probabilistic and
Differentiable Programming. &lt;a href=&#34;https://arxiv.org/abs/2007.09871&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;arXiv&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:22&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:23&#34;&gt;
&lt;p&gt;Qinheping Hu, John Cyphert, Loris D’Antoni, and Thomas Reps. Synthesis with Asymptotic Resource Bounds. &lt;em&gt;Computer Aided Verif.&lt;/em&gt; (2021). &lt;a href=&#34;https://doi.org/10.1007/978-3-030-81685-8_37&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:23&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:24&#34;&gt;
&lt;p&gt;Yican Sun, Xuanyu Peng, and Yingfei Xiong. Synthesizing Efficient Memoization Algorithms. &lt;em&gt;Object-Oriented Prog., Syst., Lang., and Applications&lt;/em&gt; (2023).&amp;#160;&lt;a href=&#34;#fnref:24&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:25&#34;&gt;
&lt;p&gt;Martin Hofmann. Linear types and non-size-increasing polynomial time computation. &lt;em&gt;Logic in Computer Science&lt;/em&gt; (1999). &lt;a href=&#34;https://doi.org/10.1109/LICS.1999.782641&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:25&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:26&#34;&gt;
&lt;p&gt;Arthur Charguéraud and François Pottier. Machine-Checked Verification of the Correctness and Amortized Complexity of an Efficient Union-Find Implementation. &lt;em&gt;Interactive Theorem Proving&lt;/em&gt; (2015). &lt;a href=&#34;https://doi.org/10.1007/978-3-319-22102-1_9&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:26&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>新闻归档</title>
      <link>https://stonebuddha.github.io/zh/news_archive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/zh/news_archive/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;[Sep 2021]&lt;/strong&gt; 我开始找 2022 年入职的学术界工作！&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Feb 2021]&lt;/strong&gt; 两篇论文 &lt;a href=&#34;publication/wanghr21b&#34;&gt;Sound Probabilistic Inference via Guide Types&lt;/a&gt; 和 &lt;a href=&#34;publication/wanghr21a&#34;&gt;Central Moment Analysis for Cost Accumulators in Probabilistic Programs&lt;/a&gt; 被 PLDI 2021 接收。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Nov 2020]&lt;/strong&gt; 预印本 &lt;a href=&#34;https://arxiv.org/pdf/2011.09037&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Probabilistic Resource-Aware Session Types&lt;/a&gt; 已上传至 arXiv。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Jun 2020]&lt;/strong&gt; 两篇论文 &lt;a href=&#34;../publication/knothwr20&#34;&gt;Liquid Resource Types&lt;/a&gt; 和 &lt;a href=&#34;../publication/wangkh20&#34;&gt;Raising Expectations: Automating Expected Cost Analysis with Types&lt;/a&gt; 被 ICFP 2020 接收。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[May 2019]&lt;/strong&gt; 论文 &lt;a href=&#34;../publication/wanghr19&#34;&gt;A Denotational Semantics for Low-Level Probabilistic Programs with Nondeterminism&lt;/a&gt; 被 MFPS 接收。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Feb 2019]&lt;/strong&gt; &lt;a href=&#34;../publication/knothwp19&#34;&gt;Resource-Guided Program Synthesis&lt;/a&gt; 被 PLDI 2019 接收。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Nov 2018]&lt;/strong&gt; &lt;a href=&#34;../publication/wangh19&#34;&gt;Type-Guided Worst-Case Input Generation&lt;/a&gt; 被 POPL 2019 接收。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Mar 2018]&lt;/strong&gt; 这是我在 SCS Day 2018 上的表演：&lt;a href=&#34;https://www.youtube.com/watch?v=zNxltZhPIG0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chengdu&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Feb 2018]&lt;/strong&gt; &lt;a href=&#34;../publication/wanghr18&#34;&gt;PMAF: An Algebraic Framework for Static Analysis of Probabilistic Programs&lt;/a&gt; 被 PLDI 2018 接收。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Jun 2017]&lt;/strong&gt; 我从北京大学毕业了。我的学位论文为&lt;a href=&#34;../../files/wang17thesis.pdf&#34;&gt;基于 Datalog 条件摘要的程序分析加速技术&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
