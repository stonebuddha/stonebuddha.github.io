<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Di Wang</title>
    <link>https://stonebuddha.github.io/</link>
      <atom:link href="https://stonebuddha.github.io/index.xml" rel="self" type="application/rss+xml" />
    <description>Di Wang</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sat, 29 Jul 2023 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://stonebuddha.github.io/media/icon_hub0ca2310ff82550007847b11be674ab8_14787_512x512_fill_lanczos_center_3.png</url>
      <title>Di Wang</title>
      <link>https://stonebuddha.github.io/</link>
    </image>
    
    <item>
      <title>Newtonian Program Analysis of Probabilistic Programs</title>
      <link>https://stonebuddha.github.io/publication/wangr23/</link>
      <pubDate>Sat, 29 Jul 2023 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/publication/wangr23/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Algebraic Program Analysis of Probabilistic Programs</title>
      <link>https://stonebuddha.github.io/talk/algebraic-program-analysis-of-probabilistic-programs/</link>
      <pubDate>Fri, 30 Jun 2023 15:15:00 +0800</pubDate>
      <guid>https://stonebuddha.github.io/talk/algebraic-program-analysis-of-probabilistic-programs/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Type-Driven Programming Language Design (In Chinese)</title>
      <link>https://stonebuddha.github.io/talk/type-driven-programming-language-design-in-chinese/</link>
      <pubDate>Sat, 17 Jun 2023 09:00:00 +0800</pubDate>
      <guid>https://stonebuddha.github.io/talk/type-driven-programming-language-design-in-chinese/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Resource-Safe System Programming Language (In Chinese)</title>
      <link>https://stonebuddha.github.io/talk/resource-safe-system-programming-language-in-chinese/</link>
      <pubDate>Fri, 19 May 2023 15:30:00 +0800</pubDate>
      <guid>https://stonebuddha.github.io/talk/resource-safe-system-programming-language-in-chinese/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Intuitionistic Logics and Programing Languages (In Chinese)</title>
      <link>https://stonebuddha.github.io/talk/intuitionistic-logics-and-programing-languages-in-chinese/</link>
      <pubDate>Tue, 28 Mar 2023 15:00:00 +0800</pubDate>
      <guid>https://stonebuddha.github.io/talk/intuitionistic-logics-and-programing-languages-in-chinese/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Probabilistic Resource-Aware Session Types</title>
      <link>https://stonebuddha.github.io/publication/daswh23/</link>
      <pubDate>Sun, 15 Jan 2023 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/publication/daswh23/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Quantitative Program Analysis and Verification (In Chinese)</title>
      <link>https://stonebuddha.github.io/talk/quantitative-program-analysis-and-verification-in-chinese/</link>
      <pubDate>Thu, 22 Dec 2022 14:00:00 +0800</pubDate>
      <guid>https://stonebuddha.github.io/talk/quantitative-program-analysis-and-verification-in-chinese/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Bayesian Synthesis in OCaml</title>
      <link>https://stonebuddha.github.io/post/bayesian-synthesis-in-ocaml/</link>
      <pubDate>Wed, 30 Nov 2022 09:38:59 +0800</pubDate>
      <guid>https://stonebuddha.github.io/post/bayesian-synthesis-in-ocaml/</guid>
      <description>&lt;p&gt;This post aims at reproducing some results from Saad et al.&amp;rsquo;s paper on Bayesian synthesis&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; in &lt;a href=&#34;https://dev.realworldocaml.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;OCaml&lt;/a&gt;, an industrial strength functional programming language.
A complete notebook for the code in this post can be found &lt;a href=&#34;notebook.html&#34;&gt;&lt;strong&gt;here&lt;/strong&gt;&lt;/a&gt;.
The data used for a Bayesian-style time-series analysis can be found &lt;a href=&#34;airline.csv&#34;&gt;&lt;strong&gt;here&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;environment-setup&#34;&gt;Environment Setup&lt;/h2&gt;
&lt;p&gt;The code in this post is tested under OCaml 4.14.0 on macOS 12.6.1 with an M2 chip.
The environment is supposed to contain a Python distribution with &lt;a href=&#34;https://jupyter.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;jupyter&lt;/a&gt; and &lt;a href=&#34;https://matplotlib.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;matplotlib&lt;/a&gt; installed.
The code should also work on macOS (or Linux) with Intel/AMD chips.&lt;/p&gt;
&lt;p&gt;I am maintaining a &lt;code&gt;ppl&lt;/code&gt; repo that contains some extensions of existing OCaml packages.
We will use &lt;code&gt;libtorch&lt;/code&gt; in this post and we need to pin the &lt;code&gt;ocaml-torch&lt;/code&gt; package to version &lt;code&gt;0.14&lt;/code&gt;, because currently the only M1/M2-compatible &lt;code&gt;libtorch&lt;/code&gt; library provided by my &lt;code&gt;ppl&lt;/code&gt; repo is only compatible with this version of &lt;code&gt;ocaml-torch&lt;/code&gt;.
The &lt;code&gt;torch_ext.0.14&lt;/code&gt; and &lt;code&gt;matplotlib.20221112&lt;/code&gt; packages are provided by my &lt;code&gt;ppl&lt;/code&gt; repo:
the former adds some functionality about probability distributions on tensors
and the latter supports more plotting controls and functions.
We will use &lt;code&gt;owl&lt;/code&gt; for parsing CSV files.
For M1/M2 users, you may need to refer to this &lt;a href=&#34;https://github.com/owlbarn/owl/issues/569#issuecomment-1119470541&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;comment&lt;/a&gt; to install &lt;code&gt;owl&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;opam remote add ppl https://github.com/stonebuddha/ppl-opam.git
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;opam pin https://github.com/LaurentMazare/ocaml-torch.git#0.14 --with-version=0.14
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;opam install core jupyter
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;opam install torch_ext.0.14 matplotlib.20221112
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;opam install owl
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The following command registers OCaml as a jupyter kernel (you might take a look at the installation log of the OCaml &lt;code&gt;jupyter&lt;/code&gt; package to find out the exact command):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;jupyter kernelspec install --name ocaml-jupyter /PATH/TO/YOUR/OCAML/SWITCH/share/jupyter
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For Anaconda-based Python distributions, or for Python distributions that are not linked to standard paths for looking for runtime libraries, you might need to update the &lt;code&gt;kernels/ocaml-jupyter/kernel.json&lt;/code&gt; file located in your jupyter installation.
For example, I need to add the following environment variable before invoking &lt;code&gt;ocaml-jupyter-kernel&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-text&#34; data-lang=&#34;text&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;DYLD_LIBRARY_PATH=/opt/homebrew/anaconda3/lib:$DYLD_LIBRARY_PATH
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, we need to add the following code to the &lt;code&gt;.ocamlinit&lt;/code&gt; file (which should be located in your home folder):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ocaml&#34; data-lang=&#34;ocaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;use&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;topfind&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nn&#34;&gt;Topfind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ignore&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now you should be able to create and run an OCaml notebook in jupyter.&lt;/p&gt;
&lt;h2 id=&#34;ocaml-torch-basics&#34;&gt;OCaml Torch Basics&lt;/h2&gt;
&lt;p&gt;Here is the &lt;a href=&#34;https://github.com/LaurentMazare/ocaml-torch/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;link&lt;/a&gt; to the official introduction of the &lt;code&gt;ocaml-torch&lt;/code&gt; package.
Most APIs are directly generated from &lt;code&gt;libtorch&lt;/code&gt;, and thus similar to the APIs of PyTorch, but in a more functional way.
Tensors are of type &lt;code&gt;Tensor.t&lt;/code&gt; and scalars are of type &lt;code&gt;Scalar.t&lt;/code&gt;.
Because OCaml is statically and strongly typed, we cannot directly multiply a tensor with a floating-point number; instead, we need to first embed a floating-point number as a scalar via &lt;code&gt;Scalar.f : float -&amp;gt; Scalar.t&lt;/code&gt; and then perform the tensor-scalar multiplication via &lt;code&gt;Tensor.mul_scalar : Tensor.t -&amp;gt; Scalar.t -&amp;gt; Tensor.t&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;One benefit of this programming style is that it removes many runtime checks because we know the type information at compile time.
However, this style is not very succinct compared to Python.
Even worse, lack of ad-hoc polymorphism (e.g., operator overloading) makes programming in OCaml more inconvenient than Haskell in this setting.
One workaround is that OCaml supports &lt;em&gt;scoped function calls&lt;/em&gt; (operators are also functions).
For example, if &lt;code&gt;t1 : Tensor.t&lt;/code&gt; and &lt;code&gt;t2 : Tensor.t&lt;/code&gt; are two tensors of the same shape,
we can write &lt;code&gt;Tensor.(t1 + t2)&lt;/code&gt; for pointwise addition of the two tensors.&lt;/p&gt;
&lt;h2 id=&#34;gaussian-process-regression&#34;&gt;Gaussian Process Regression&lt;/h2&gt;
&lt;p&gt;Readers can refer to the textbook &lt;a href=&#34;https://direct.mit.edu/books/book/2320/Gaussian-Processes-for-Machine-Learning&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Gaussian Processes for Machine Learning&lt;/a&gt; for more details on Gaussian Processes.
In this post, we focus on a Bayesian-style time-series analysis based on Gaussian Process Regression.
Let $\mathbb{T}$ be an index set and $X \triangleq \{ X(t) \mid t \in \mathbb{T} \}$ be a collection of real-valued random variables.
We say $X$ is a &lt;em&gt;Gaussian Process&lt;/em&gt; if for any $\mathbf{t} = [t_1, t_2, \cdots, t_n]$ of distinct indexes, the random vector $X(\mathbf{t}) \triangleq [X(t_1), X(t_2), \cdots, X(t_n)]$ has a joint Gaussian distribution.&lt;/p&gt;
&lt;p&gt;We can represent a Gaussian Process by its &lt;em&gt;mean function&lt;/em&gt; $m : \mathbb{T} \to \mathbb{R}$ and &lt;em&gt;covariance function&lt;/em&gt; $k : \mathbb{T} \times \mathbb{T} \to \mathbb{R}$ that satisfy for all $t,t&amp;rsquo; \in \mathbb{T}$, it holds that $m(t) = \mathbb{E}[X(t)]$ and $k(t,t&amp;rsquo;) = \mathbb{E}[ (X(t) - m(t)) (X(t&amp;rsquo;) - m(t&amp;rsquo;))]$.
Let $m(\mathbf{t})$ denote the mean vector $[m(t_1), m(t_2), \cdots, m(t_n)]$.
Let $k(\mathbf{t}, \mathbf{t})$ denote the covariance matrix whose $i j$ entry is $k(t_i, t_j)$.
We denote by $X \sim \mathrm{GP}(m,k)$ a Gaussian Process $X$ with mean $m$ and covariance $k$.
For one-dimensional continuous time series (which we consider in this post), we can assume that $\mathbb{T} = \mathbb{R}$.&lt;/p&gt;
&lt;p&gt;The joint probability density of $X(\mathbf{t})$ at a real vector $x(\mathbf{t}) \triangleq [x(t_1), x(t_2), \cdots, x(t_n)]$ is
$$
\begin{align}
\log p(x(\mathbf{t})) &amp;amp; = -\frac{1}{2} \biggl[ (x(\mathbf{t}) - m(\mathbf{t}))^\mathsf{T} k(\mathbf{t}, \mathbf{t})^{-1} ( x(\mathbf{t}) - m(\mathbf{t}) ) \\
&amp;amp; \qquad\qquad {} - \log (\det k(\mathbf{t}, \mathbf{t})) \\
&amp;amp; \qquad\qquad {} - n \log (2\pi) \biggr] .
\end{align}
$$
Multivariate Gaussian distributions are closed under conditioning, thus the posterior distribution of $X(\mathbf{t}&amp;rsquo;)$ at new time indexes $\mathbf{t}&amp;rsquo;$ is also a multivariate Gaussian:
$$
\begin{align}
X(\mathbf{t}&amp;rsquo;) \mid X(\mathbf{t}) = x(\mathbf{t}) &amp;amp; \sim \mathrm{MultivariateGaussian}(m_{post}(\mathbf{t}&amp;rsquo;), k_{post}(\mathbf{t}&amp;rsquo;, \mathbf{t}&amp;rsquo;)), \\
m_{post}(\mathbf{t&amp;rsquo;}) &amp;amp; \triangleq k(\mathbf{t}&amp;rsquo;, \mathbf{t}) k(\mathbf{t}, \mathbf{t})^{-1} x(\mathbf{t}), \\
k_{post}(\mathbf{t&amp;rsquo;}, \mathbf{t}&amp;rsquo;) &amp;amp; \triangleq k(\mathbf{t}&amp;rsquo;, \mathbf{t}&amp;rsquo;) - k(\mathbf{t}&amp;rsquo;, \mathbf{t}) k(\mathbf{t}, \mathbf{t})^{-1} k(\mathbf{t}, \mathbf{t}&amp;rsquo;).
\end{align}
$$&lt;/p&gt;
&lt;p&gt;One can easily add i.i.d. noises to a Gaussian Process.
Consider $Z \sim \mathrm{GP}(m, k)$ and $X(t) \triangleq Z(t) + \gamma(t)$ where $\gamma(t) \sim \mathrm{Gaussian}(0, \varepsilon)$ for any $t \in \mathbb{T}$.
We then say $X$ is a Gaussian Process &lt;em&gt;with output noise $\varepsilon$&lt;/em&gt;, written $X \sim \mathrm{NoisyGP}(m,k,\varepsilon)$.
One can show that $X$ itself is indeed a Gaussian Process $X \sim \mathrm{GP}(m,k&amp;rsquo;)$ where $k&amp;rsquo;$ is defined as $k&amp;rsquo;(t,t&amp;rsquo;) \triangleq k(t,t&amp;rsquo;) + [t=t&amp;rsquo;] \cdot \varepsilon$ for all $t,t&amp;rsquo; \in \mathbb{T}$.&lt;/p&gt;
&lt;p&gt;See the &lt;code&gt;compute_log_likelihood&lt;/code&gt; function and the &lt;code&gt;get_conditional_mu_cov&lt;/code&gt; function in the notebook for computing likelihoods and posterior parameters.&lt;/p&gt;
&lt;h2 id=&#34;gp-synthesis-via-mcmc&#34;&gt;GP Synthesis via MCMC&lt;/h2&gt;
&lt;p&gt;There have been many methods for defining the covariance function of a Gaussian Process.
The grammar below shows one method using a &lt;em&gt;domain-specific language&lt;/em&gt; (DSL), thus enabling an expressive set of (possibly very complex) covariance functions:
$$
\begin{align}
E &amp;amp; ::= \texttt{NoisyGP}(0, K, \varepsilon) \\
K &amp;amp; ::= \texttt{Constant}(\varphi) \mid \texttt{Linear}(\theta) \mid \texttt{Squared_exponential}(\varphi) \\
&amp;amp; \mid \texttt{Periodic}(\varphi_1, \varphi_2) \mid K_1 + K_2 \mid K_1 * K_2 \\
&amp;amp; \varepsilon \in \mathbb{R}_{&amp;gt; 0} \qquad \theta \in \mathbb{R} \qquad \varphi \in \mathbb{R}_{&amp;gt; 0}
\end{align}
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\texttt{Constant}(\varphi)$: the parameter $\varphi$ means the variance of a constant process around $0$.&lt;/li&gt;
&lt;li&gt;$\texttt{Linear}(\theta)$: the parameter $\theta$ means the time intercept of a linear process, i.e., $X(\theta) = 0$ with probability one.&lt;/li&gt;
&lt;li&gt;$\texttt{Squared_exponential}(\varphi)$: the parameter $\varphi$ means the length scale of a stationary smooth process.&lt;/li&gt;
&lt;li&gt;$\texttt{Periodic}(\varphi_1, \varphi_2)$: the parameter $\varphi_1$ means the length scale of a periodic process, and the parameter $\varphi_2$ represents the frequency of the process.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In a Bayesian-style time-series analysis, we model unknown quantities as random variables and known data as generated observations.
For any $n &amp;gt; 0$ and distinct time indexes $\mathbf{t} = [t_1, t_2, \cdots, t_n]$, the generative model is&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Sample a noise level $\varepsilon \sim P(\varepsilon)$ (e.g., a Gamma prior).&lt;/li&gt;
&lt;li&gt;Sample a covariance expression $K \sim P(K)$ (e.g., the &lt;code&gt;covariance_prior&lt;/code&gt; function in the notebook, which implements a probabilistic context-free grammar).&lt;/li&gt;
&lt;li&gt;Sample time-series data $X(\mathbf{t}) \sim \mathrm{NoisyGP}(0, K, \varepsilon)$. (See the &lt;code&gt;eval_cov_mat&lt;/code&gt; function in the notebook for how to translate an expression in the DSL to a covariance function.)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Running Bayesian inference on the generative model above with the real vector $x(\mathbf{t}) = [x(t_1), x(t_2), \cdots, x(t_n)]$ essentially performs a &lt;em&gt;Bayesian synthesis&lt;/em&gt; of the covariance expression $K$.
Markov-chain Monte Carlo (MCMC) is a popular sampling-based method for Bayesian inference; it allows us to sample from the posterior distribution $P(\varepsilon, K \mid X(\mathbf{t}) = x(\mathbf{t}))$.
MCMC works by constructing a Markov chain over latent random variables ($\varepsilon$ and $K$ in this case),
and the chain is usually generated from a &lt;em&gt;proposal&lt;/em&gt; kernel that generates new candidates for latent variables from their current values.
The proposed new values are accepted with respect to the &lt;a href=&#34;https://en.wikipedia.org/wiki/Metropolis%e2%80%93Hastings_algorithm&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;em&gt;Metropolis-Hastings&lt;/em&gt; criterion&lt;/a&gt;.
The &lt;code&gt;mh_resample_noise&lt;/code&gt; function in the notebook simply generates a fresh noise level from a Gamma distribution.
The &lt;code&gt;mh_resample_subtree_unbiased&lt;/code&gt; function implements a more involved mechanism that unbiasedly selects a node in the AST of the covariance expression $K$
and replaces the subtree rooted at that node with a freshly generated sub-expression.
The &lt;code&gt;run_mcmc&lt;/code&gt; function then runs an epoch of the MCMC method by resampling repeatedly for a few times.
The last cell of the notebook demonstrates the effectiveness of the Bayesian-synthesis approach on a time-series analysis of revenue passenger miles for US air carrier domestic flights.&lt;/p&gt;
&lt;h2 id=&#34;next-steps&#34;&gt;Next Steps&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;How to write tensor-manipulation code more easily in a statically and strongly typed language like OCaml?&lt;/li&gt;
&lt;li&gt;How to develop a lightweight mechanism that checks tensor shape compatibility at compile time?&lt;/li&gt;
&lt;li&gt;The plotting functionality provided in this post largely depends on the Python ecosystem. How to design a plotting library with APIs that are more suitable for typed functional programming?&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Feras A. Saad, Marco F. Cusumano-Towner, Ulrich Schaechtle, Martin C. Rinard, and Vikash K. Mansinghka. 2019. Bayesian Synthesis of Probabilistic Programs for Automatic Data. &lt;em&gt;POPL&#39;19&lt;/em&gt;.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>A Casual Introduction to Bayesian Probabilistic Programming (In Chinese)</title>
      <link>https://stonebuddha.github.io/post/introduction-to-probabilistic-programming/</link>
      <pubDate>Sun, 30 Oct 2022 17:49:57 +0800</pubDate>
      <guid>https://stonebuddha.github.io/post/introduction-to-probabilistic-programming/</guid>
      <description>&lt;p&gt;人们近年来在人工智能领域取得的进展，除了层出不穷的新算法，也仰仗硬件算力的提升并得益于编程语言层面对自动微分和张量运算的支持。
基于神经网络的机器学习在很多应用中取得了成功，但在一些方面也尚存不足，例如对预测结果信度的评估&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，纳入领域知识的方法&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;，以及在观测数据的分布发生改变时的鲁棒性&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。
&lt;strong&gt;贝叶斯推断&lt;/strong&gt;（Bayesian Inference）是一种历史悠久的、基于&lt;strong&gt;概率&lt;/strong&gt;的贝叶斯解释（而非频率解释）的、在上述三个方面有一些优势的机器学习方法，其核心在于通过观测数据来估计模型假设空间的概率分布，而非选择出单个“最优”假设：设 $\Theta$ 为假设空间、$x$ 为观测数据，每个假设 $\theta \in \Theta$ 具有一个先验概率 $\mathbb{P}(\theta)$，而一个贝叶斯模型则描述了观测数据在给定假设下的条件概率 $\mathbb{P}(x \mid \theta)$，那么由贝叶斯法则，我们可用观测数据更新模型假设的后验概率：
$$
\mathbb{P}(\theta \mid x) = \frac{ \mathbb{P}(x \mid \theta) \mathbb{P}(\theta) }{ \sum_{\theta&amp;rsquo; \in \Theta} \mathbb{P}(x \mid \theta&amp;rsquo;) \mathbb{P}(\theta&amp;rsquo;) } \qquad (\theta \in \Theta).
$$
基于贝叶斯推断的机器学习也被称为&lt;strong&gt;贝叶斯机器学习&lt;/strong&gt;&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;。
然而，相比基于梯度下降等算法的机器学习方法，贝叶斯推断的计算复杂度更高，这阻挡了贝叶斯机器学习在更多领域、更大模型上的应用。&lt;/p&gt;
&lt;p&gt;为了更快更好地进行贝叶斯推断，&lt;strong&gt;概率编程&lt;/strong&gt;&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;逐渐成为一个活跃的研究领域。
概率编程旨在分离描述概率模型和进行贝叶斯推断这两个步骤，通过良好的编程语言设计来支持丰富的模型种类，通过编程语言的各类技术（如编译优化、动态分析、元编程等）来自动、高效地进行贝叶斯推断。
人们已经设计、开发了多个概率编程语言（如 Stan、Pyro、Gen.jl 等），但如何平衡&lt;strong&gt;正确性&lt;/strong&gt;和&lt;strong&gt;灵活性&lt;/strong&gt;仍然是该领域的一个重要研究问题。
一方面，设计有语义限制的概率编程语言并提供特化的推断算法，可以保证正确性和高效性，但是语言可表达的模型种类受限，也难以重用已有的非概率的计算模块；另一方面，使用通用编程语言来描述概率模型，并允许用户对通用推断算法进行定制，可以满足灵活性和一定程度上的高效性&lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:8&#34;&gt;&lt;a href=&#34;#fn:8&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;，但是用户定制会使得正确性的保证变得困难。
正如自动微分框架驱动了基于神经网络的机器学习的发展，我们期待一个&lt;strong&gt;正确而灵活的概率编程框架&lt;/strong&gt;能驱动贝叶斯机器学习的进一步发展和流行。&lt;/p&gt;
&lt;p&gt;在这里，我们看一个使用概率编程来进行时间序列的在线学习的例子&lt;sup id=&#34;fnref:9&#34;&gt;&lt;a href=&#34;#fn:9&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;9&lt;/a&gt;&lt;/sup&gt;。
该例子希望学习并预测美国的月度民航总里程数的走势（&lt;a href=&#34;https://fred.stlouisfed.org/series/RPM&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;数据来源&lt;/a&gt;）。下图为 2009 年 1 月至 2020 年 2 月的数据：
&lt;a href=&#34;airline.png&#34;&gt;&lt;img src=&#34;airline.png&#34; width=&#34;500&#34;/&gt;&lt;/a&gt;
在贝叶斯机器学习中，高斯过程回归（Gaussian Process Regression）是一种灵活的算法，该方法允许我们使用核函数（Kernel Function）来定制多元高斯分布的的协方差矩阵。
通过概率编程，我们可以不用预先指定使用什么形式的核函数，而是写一段程序来声明核函数形式的先验概率分布（换句话说，我们可以把&lt;strong&gt;结构&lt;/strong&gt;的选择也纳入模型假设 $\theta$ 中）。
下面的代码通过概率上下文无关文法（Probabilistic Context-Free Grammar）的方式实现了这样的一个先验概率分布：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ocaml&#34; data-lang=&#34;ocaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Constant&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;of&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Linear&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;of&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Plus&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;of&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;rec&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel_prior&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel_type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;categorical&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;in&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;match&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel_type&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;with&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Constant&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rand&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;(* Constant (C): k(x, x&amp;#39;) = C *)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Linear&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rand&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;(* Linear (C): k(x, x&amp;#39;) = (x - C) * (x&amp;#39; - C) *)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Plus&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;kernel_prior&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kernel_prior&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c&#34;&gt;(* Plus (k1, k2): k(x, x&amp;#39;) = k1(x, x&amp;#39;) + k2(x, x&amp;#39;) *)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结合序列蒙特卡洛（Sequential Monte Carlo）方法，我们可以实现一个基于高斯过程的时间序列的在线学习算法，该算法可以估计预测的不确定性，并在数据分布发生改变时即时响应。
下面这个动画展示了在线学习的效果，其中灰色的区域为使用 100 个对后验概率分布的采样做出的 95% 置信度预测区间的叠加：
&lt;a href=&#34;airline1.gif&#34;&gt;&lt;img src=&#34;airline1.gif&#34; width=&#34;500&#34;/&gt;&lt;/a&gt;
可以看出，在数据比较多的时候，算法已经对整个趋势的掌握已经非常不错了。而下面的动画则展示在 2020 年 2 月之后的数据上的效果：
&lt;a href=&#34;airline2.gif&#34;&gt;&lt;img src=&#34;airline2.gif&#34; width=&#34;500&#34;/&gt;&lt;/a&gt;
很明显，新冠疫情导致了民航数据的突变，而基于贝叶斯推断的在线学习可以及时对这种变化进行响应并调整之后的预测。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Chuan Guo, Geoff Pleiss, Yu Sun, and Kilian Q. Weinberger. 2017. On Calibration of Modern Neural Networks. &lt;em&gt;ICML&#39;17&lt;/em&gt;.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Nikhil Muralidhar, Mohammad Raihanul Islam, Manish Marwah, Anuj Karpatne, and Naren Ramakrishnan. 2018. Incorporating Prior Domain Knowledge into Deep Neural Networks. &lt;em&gt;ICBD&#39;18&lt;/em&gt;.&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;Dario Amodei, Chris Olah, Jacob Steinhardt, Paul Christiano, John Schulman,and Dan Mané. 2016. Concrete Problems in AI Safety. &lt;a href=&#34;https://arxiv.org/abs/1606.06565&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://arxiv.org/abs/1606.06565&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;Zoubin Ghahramani. 2015. Probabilistic machine learning and artiicial intelligence. &lt;em&gt;Nature&lt;/em&gt;, 521.&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;
&lt;p&gt;Joshua B. Tenenbaum, Charles Kemp, Thomas L. Grifiths, and Noah D. Goodman. 2011. How to Grow a Mind: Statistics, Structure, and Abstraction. &lt;em&gt;Science&lt;/em&gt;, 331, 6022.&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34;&gt;
&lt;p&gt;Jan Willem van de Meent, Brooks Paige, Hongseok Yang, and Frank Wood. 2018. An Introduction to Probabilistic Programming. &lt;a href=&#34;https://arxiv.org/abs/1809.10756&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://arxiv.org/abs/1809.10756&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34;&gt;
&lt;p&gt;Vikash K. Mansinghka, Ulrich Schaechtle, Shivam Handa, Alexey Radul, Yutian Chen, and Martin C. Rinard. 2018. Probabilistic Programming with Programmable Inference. &lt;em&gt;PLDI&#39;18&lt;/em&gt;.&amp;#160;&lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:8&#34;&gt;
&lt;p&gt;Eli Bingham, Jonathan P. Chen, Martin Jankowiak, Fritz Obermeyer, Neeraj Pradhan, Theofanis Karaletsos, Rishabh Singh, Paul Szerlip, Paul Horsfall, and Noah D. Goodman. 2018. Pyro: Deep Universal Probabilistic Programming. &lt;em&gt;J. Machine Learning Research&lt;/em&gt;, 20, 1.&amp;#160;&lt;a href=&#34;#fnref:8&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:9&#34;&gt;
&lt;p&gt;Feras A. Saad, Marco F. Cusumano-Towner, Ulrich Schaechtle, Martin C. Rinard, and Vikash K. Mansinghka. 2019. Bayesian Synthesis of Probabilistic Programs for Automatic Data. &lt;em&gt;POPL&#39;19&lt;/em&gt;.&amp;#160;&lt;a href=&#34;#fnref:9&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>A Casual Introduction to Algebraic Program Analysis (In Chinese)</title>
      <link>https://stonebuddha.github.io/post/introduction-to-algebraic-program-analysis/</link>
      <pubDate>Sun, 02 Oct 2022 22:51:11 +0800</pubDate>
      <guid>https://stonebuddha.github.io/post/introduction-to-algebraic-program-analysis/</guid>
      <description>&lt;p&gt;本文参考了 Zachary Kincaid 和 Thomas Reps 在 CAV 2021 上的关于&lt;strong&gt;代数程序分析&lt;/strong&gt;（Algebraic Program Analysis）的教程&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;代数程序分析简单来说就是一种基于&lt;strong&gt;代数结构&lt;/strong&gt;来设计程序分析的方法论：某种代数结构中的元素代表了程序的含义，而其上的运算则代表组合程序含义的方式。
这其实跟我们在程序语法树上用结构递归定义指称语义（Denotational Semantics）的方式类似：
$$
\begin{align}
\mathcal{A}[{-}] &amp;amp; : \mathit{Program} \to \mathit{Meaning} \\
\mathcal{A}[S_1;S_2] &amp;amp; = \mathcal{A}[S_1] \cdot \mathcal{A}[S_2] \\
\mathcal{A}[\mathbf{if}(*)\{S_1\}\mathbf{else}\{S_2\}] &amp;amp; = \mathcal{A}[S_1] + \mathcal{A}[S_2] \\
\mathcal{A}[\mathbf{while}(*)\{S_0\}] &amp;amp; = (\mathcal{A}[S_0])^*
\end{align}
$$
而上面式子中的 $\cdot$、$+$ 和 $^*$ 就可以视作某种代数结构所支持的运算。
这种方式具有良好的 Compositionality：&lt;strong&gt;一个程序的含义总是由该程序的组成部分的含义结合而来&lt;/strong&gt;。
例如，如果上面的 $\mathcal{A}$ 代表了一个程序分析，那么我们需要指定如何实现连接（$\cdot$）、分支（$+$）和循环（$^*$）这三种运算。
注意，这里出现了一个与传统基于&lt;strong&gt;迭代&lt;/strong&gt;的程序分析的重要不同：一个循环语句的含义并不是由反复迭代循环体直到不动点来获得，而是通过一个&lt;strong&gt;显式&lt;/strong&gt;的 $^*$ 运算来获得。
换句话说，代数程序分析允许我们使用别的（非迭代的）方式来分析循环，这就为我们设计新的程序分析技术提供了可能性。&lt;/p&gt;
&lt;p&gt;在本文中，我们考虑通过&lt;strong&gt;状态转移公式代数&lt;/strong&gt;（Transition Formula Alegebras）来分析程序变量间的数值关系。
一个状态转移公式$F(X,X&amp;rsquo;)$是一个逻辑公式，它描述了程序状态上的转移关系：$X$ 集合表示前状态（pre-state）的变量，$X&amp;rsquo;$ 集合表示后状态（post-state）的变量。
比如我们考虑变量有 $x,y$，那么程序语句 &lt;code&gt;x = x + 1;&lt;/code&gt; 的状态转移公式就是 $x&amp;rsquo; = x + 1 \wedge y&amp;rsquo; = y$。
对于一个固定的变量集合 $X$，我们考虑在所有可能的状态转移公式 $F(X,X&amp;rsquo;)$ 上建立一个适用于程序分析的代数结构。
在传统程序分析中，我们往往需要预先对可能的公式&lt;strong&gt;进行限制&lt;/strong&gt;来使得迭代算法可以收敛：例如，只考虑变量间的线性不等式。
在代数程序分析中，我们不需要这种预先的限制，而是可以在实现循环运算（$^*$）时以即插即用的方式使用不同的近似方法。
在状态转移公式代数中，我们定义常数 $0$ 为 $\mathit{false}$，常数 $1$ 为 $\bigwedge_{x \in X} (x&amp;rsquo; = x)$，分支运算为 $F + G = F \vee G$，连接运算为 $F \cdot G = \exists X&amp;rsquo;&amp;rsquo;. F(X,X&amp;rsquo;&amp;rsquo;) \wedge G(X&amp;rsquo;&amp;rsquo;,X&amp;rsquo;)$（即用 $X&amp;rsquo;&amp;rsquo;$ 来表示中间状态）。
而对于循环运算 $({-})^* : \mathit{TransitionFormula} \to \mathit{TransitionFormula}$，我们只需考虑在转移公式这一层面进行计算，并不用考虑循环语句本身可能有的嵌套循环结构！
换句话说，我们可以借鉴已有的各种 Loop Summarization / Acceleration 技术。&lt;/p&gt;
&lt;p&gt;在这里，我们只讨论一种基于&lt;strong&gt;区间分析&lt;/strong&gt;的循环运算实现方法（本文开头提到的参考材料中有更多的例子）。
在区间分析中，我们一般考虑形如 $\bigwedge_{x \in X} (a_x \le x \le b_x)$ 的状态公式，其中 $a_x,b_x$ 为常数。
例如，对于下面这个程序中的循环而言，$0 \le i \le 10 \wedge 0 \le j \le 20$ 是一个区间不变量，但是 $0 \le i \le 10 \wedge 0 \le j \le 10$ 并不是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;传统的基于区间的程序分析会使用 widening / narrowing 等技术来确保迭代分析可以收敛，但这会影响分析的精度。
在代数程序分析的框架中，我们则拥有更好的自由度来设计对于循环的分析：考虑循环体的转移公式为 $F(X,X&amp;rsquo;)$，那么断言“$A = \{ a_x \mid x \in X \}$ 和 $B = \{ b_x \mid x \in X \}$构成一个区间不变量”可以表述为下面的公式：
$$
\forall X, X&amp;rsquo;. \left(\left(\bigwedge_{x \in X}(a_x \le x \le b_x)\right) \wedge F(X,X&amp;rsquo;)\right) \implies \bigwedge_{x \in X} (a_x \le x&amp;rsquo; \le b_x)
$$
令 $Inv(A,B)$ 为上面这个式子。那么循环运算 $F^{*}$ 可以定义为：
$$
\forall A, B. \left( Inv(A,B) \wedge \bigwedge_{x \in X} (a_x \le x \le b_x) \right) \implies \bigwedge_{x \in X} (a_x \le x&amp;rsquo; \le b_x)
$$
这种循环运算的实现蕴含了&lt;strong&gt;所有&lt;/strong&gt;可以由循环体转移公式 $F$ 得出的区间不变量！&lt;/p&gt;
&lt;p&gt;前面我们提到，代数程序分析要求在程序语法树上进行&lt;strong&gt;结构&lt;/strong&gt;递归，那么在&lt;strong&gt;非结构&lt;/strong&gt;的程序上（例如有 &lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;continue&lt;/code&gt;），我们是否还能进行代数程序分析呢？
答案再次由 Robert Tarjan 给出：&lt;strong&gt;Yes&lt;/strong&gt;！（至于为什么用“再”可以看我&lt;a href=&#34;../introduction-to-static-resource-analysis&#34;&gt;上次的分享&lt;/a&gt;。)
Tarjan 的两篇文章 &lt;a href=&#34;https://doi.org/10.1145/322261.322273&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fast Algorithms for Solving Path Problems&lt;/a&gt; 和 &lt;a href=&#34;https://doi.org/10.1145/322261.322272&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;A Unified Approach to Path Problems&lt;/a&gt; 中提出了一种高效的基于代数的在图上解决路径问题的算法：这里的路径问题指的是图中的边上有权值，一条路径的权值为其中边权相&lt;strong&gt;乘&lt;/strong&gt;，然后我们想要计算符合某种条件的所有路径的权值&lt;strong&gt;和&lt;/strong&gt;（这里的&lt;strong&gt;乘&lt;/strong&gt;和&lt;strong&gt;和&lt;/strong&gt;都是抽象的，例如如果权值为非负数，&lt;strong&gt;乘&lt;/strong&gt;为加，&lt;strong&gt;和&lt;/strong&gt;为取最小值，那么路径问题描述的则是最短路问题）。
Tarjan 提出了一种可以计算图上两点间所有路径的集合的高效算法，其关键点在于这个（可能无穷的）路径集合可以表述为一个有限的&lt;strong&gt;正则表达式&lt;/strong&gt;，其后解路径问题就可以转化为在一个描述问题的代数结构中解释正则表达式：这与我们上文描述的三种运算（连接 $\cdot$，分支 $+$，循环 $^*$）正好是符合的！
所以，对于非结构的程序，我们可以把它表示成一个控制流图，然后通过 Tarjan 的算法计算出描述所有可能的程序执行路径的正则表达式，最后在描述程序分析的代数结构中解释该正则表达式。
例如，以下程序&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;中的所有可能路径的集合可以表述为下面的正则表达式：
$$\small
\left(\fbox{m=0} \cdot \left(\fbox{m&amp;lt;8} \cdot \fbox{n&amp;gt;=0} \cdot \fbox{m=m+1} \cdot \fbox{n=n-1}\right)^* \cdot \fbox{m&amp;gt;=8}\right)^* \cdot \fbox{m=0} \cdot \fbox{m&amp;lt;8} \cdot \fbox{n&amp;lt;0}
$$&lt;/p&gt;
&lt;p&gt;在文章的最后，我们聊一聊代数程序分析的不足。
最明显的不足在于，尽管 Compositionality 是个好性质，它也意味着我们在程序分析中丢失了&lt;strong&gt;上下文&lt;/strong&gt;信息。
一方面，由于在分析某个程序组成部分时不能依赖其上下文，我们在分析时需要追踪更多的信息（例如上文的状态转移公式代数需要同时记录 $X$ 和 $X&amp;rsquo;$）；另一方面，我们可能会由于缺乏上下文信息而对某个程序组成部分进行过于保守的分析（这取决于程序分析状态空间设计得好不好）。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Zachary Kincaid, Thomas Reps, and John Cyphert. Algebraic Program Analysis. &lt;a href=&#34;https://doi.org/10.1007/978-3-030-81685-8_3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://doi.org/10.1007/978-3-030-81685-8_3&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Zachary Kincaid and Thomas Reps. Introduction to Algebraic Program Analysis. &lt;a href=&#34;https://www.cs.wisc.edu/wpis/talks/CAV21-Algebraic-Part1-regular.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Part 1&lt;/a&gt;, &lt;a href=&#34;https://www.cs.wisc.edu/wpis/talks/CAV21-Algebraic-Part2-foundations.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Part 2&lt;/a&gt;, &lt;a href=&#34;https://www.cs.wisc.edu/wpis/talks/CAV21-Algebraic-Part3-InterproceduralAnalysis.pptx&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Part 3&lt;/a&gt;, &lt;a href=&#34;https://www.cs.wisc.edu/wpis/talks/CAV21-Algebraic-Part4-termination.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Part 4&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>A Casual Introduction to Static Resource Analysis (In Chinese)</title>
      <link>https://stonebuddha.github.io/post/introduction-to-static-resource-analysis/</link>
      <pubDate>Sat, 10 Sep 2022 15:32:19 +0800</pubDate>
      <guid>https://stonebuddha.github.io/post/introduction-to-static-resource-analysis/</guid>
      <description>&lt;p&gt;简单地说，程序的&lt;strong&gt;资源分析&lt;/strong&gt;（Resource Analysis）指的是把该程序的资源消耗表示成一个关于程序输入的函数。
这里的&lt;strong&gt;资源&lt;/strong&gt;可以是运行时间、内存使用、能源消耗，或别的什么数值指标。
高德纳（Donald Knuth）在《计算机程序设计的艺术》（&lt;em&gt;The Art of Computer Programming&lt;/em&gt;）中就基于 MIX 汇编语言的语义讨论了一些资源分析的问题。
在计算机科学的课程中，资源分析通常以&lt;strong&gt;分析算法、数据结构的时间、空间复杂度&lt;/strong&gt;的形式出现，而这里面最常见的又通常是&lt;strong&gt;渐近分析&lt;/strong&gt;，即忽略常数、假定输入规模充分大时的复杂度，例如对长度为 $n$ 的数组进行归并排序时间复杂度为 $O(n \log n)$。
在这篇文章中，我们考虑一个稍微困难点的情况，即我们希望得到的分析结果是带有常数信息的&lt;strong&gt;非渐近&lt;/strong&gt;复杂度：从非渐近分析可以容易得出渐近分析的结果，而且前者还可以用来精细地比较渐近复杂度相同的算法、数据结构。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态&lt;/strong&gt;资源分析即在不实际运行程序的情况下对其进行资源分析。
Facebook 出品的 Infer 工具提供了函数级的静态运行时间分析，其宗旨是在软件开发的过程中更早地指出性能问题（比方说，在 Code Review 阶段由工具自动反馈，而不是等到后面的性能回归测试）。
下面这个例子来源于 Infer 的官方文档&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;loop&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Infer 通过静态分析对上面这个函数得出一个描述其运行时间的多项式（比如 $8|list|+16$），从而知道这个函数的时间复杂度和其输入列表的长度呈线性关系。
如果某一次代码修改把这个函数更新为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;loop&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// newly added function call
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而此处的 &lt;code&gt;foo&lt;/code&gt; 函数的时间复杂度也是与输入呈线性关系，那么 Infer 可以检测到 &lt;code&gt;loop&lt;/code&gt; 函数的复杂度从 $O(|list|)$ 增长到了 $O(|list|^2)$，并向开发者发出警报。
（如果想要更深入了解 Infer 中的资源分析，可以参考&lt;a href=&#34;https://youtu.be/-sqdJbvqeNQ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这个视频&lt;/a&gt;。）&lt;/p&gt;
&lt;p&gt;笼统地说，Infer 中的资源分析可以大致理解为对循环次数进行计数，从而将资源分析问题转化为程序变量数值关系的分析；这也是很多静态资源分析（比如 SPEED&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;）背后的原理。
在这篇文章中，我们来聊另一种颇为有趣的静态资源分析：&lt;strong&gt;自动均摊资源分析&lt;/strong&gt;（Automatic Amortized Resource Analysis，AARA）。
这种方法衍生自 Robert Tarjan 在 1985 年的一篇论文&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;，文中给出了一种推导序列操作的&lt;strong&gt;最坏&lt;/strong&gt;情况资源消耗的方法。
该方法的思路可以概括为：对于很多数据结构来说，一个操作消耗的资源很大程度上是由数据结构的状态决定的，而且有可能会根据状态有很大的不同；但是比较高的资源消耗（例如重新组织整个数据结构）往往会以一种可以预测的频率出现，也就是说，这些消耗在时间轴上&lt;strong&gt;均摊&lt;/strong&gt;了。
均摊资源分析即利用了这种思想：我们可以把程序的执行看做是一个操作序列 $s_1,s_2,s_3,\cdots$，这里的每个 $s_i \in \mathrm{State}$ 都表示一个程序状态，而我们用一个函数 $cost(s_i,s_{i+1})$ 来描述资源的消耗；然后我们设计一个&lt;strong&gt;势能函数&lt;/strong&gt; $\Phi : \mathrm{State} \to \mathbb{Q}^+$ 把程序状态映射为非负数，使得对任意的 $i$，我们有
$$
\Phi(s_{i}) \ge cost(s_{i}, s_{i+1}) + \Phi(s_{i+1}),
$$
即一个状态的势能要足以支付当前程序操作的资源消耗以及下一个程序状态的势能（思考题：$cost$ 为负时意味着什么？）。
如此以来，$\Phi(s_0)$ 给出了程序的总资源消耗的一个&lt;strong&gt;上界&lt;/strong&gt;，而我们需要做的是定义一个势能函数，并证明在每个程序执行的&lt;strong&gt;局部&lt;/strong&gt;，上述表达式成立。
这意味着均摊资源分析的 Compositionality 是很好的！&lt;/p&gt;
&lt;p&gt;我们知道，类型系统的一大特点也是 Compositionality；所以，设计一个&lt;strong&gt;用于均摊资源分析的类型系统&lt;/strong&gt;是非常自然的想法。
考虑下面这段 OCaml 代码，它是连接两个列表的简单实现，而我们想要分析它递归调用的次数（这也是一种资源消耗）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ocaml&#34; data-lang=&#34;ocaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;rec&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;append&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;l1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;match&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l1&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;with&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rest&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;append&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;in&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rest&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我们能够很容易地看出 &lt;code&gt;append&lt;/code&gt; 函数递归调用的次数是 $|l_1|$。
假定这个 &lt;code&gt;append&lt;/code&gt; 函数的类型为 $L(\alpha) \times L(\alpha) \to L(\alpha)$，这里的 $L$ 即表示列表类型。
均摊分析要求我们给程序状态赋予势能，在这个例子中，我们则需要把我们的势能放在 &lt;code&gt;append&lt;/code&gt; 的参数 $l_1$ 和 $l_2$ 里。
让我们给列表类型增加一个数值标注：用 $L^q(\alpha)$ 表示一个列表类型，其中的&lt;strong&gt;每个元素都携带了 $q$ 单位的势能&lt;/strong&gt;，并假定所有程序操作的资源消耗都是 $0$，除了递归调用的消耗为 $1$ 单位。
所以，&lt;code&gt;append&lt;/code&gt; 的带资源标注的类型可以写为 $L^1(\alpha) \times L^0(\alpha) \to L^0(\alpha)$：如果我们计算参数和结果之间的势能差，我们就能发现那恰好是 $|l_1|$。
但是，我们如何通过类型系统来检查这个类型是不是正确的呢？
还记得 Compositionality 吗——我们只需要对局部操作验证一下势能不等式：比如，在模式匹配时，如果 $l_1$ 非空，那么我们把它解构为 $x$ 和 $xs$，其中 $xs$ 的类型与 $l_1$ 相同，为 $L^1(\alpha)$，但是 $xs$ 的长度比 $l_1$ 少 $1$，所以这一步解构给了我们 $1$ 单位的自由势能，我们可以用它来支付紧接着的这个递归调用。
接着我们检查 $xs$ 和 $l_2$ 的类型是否符合 &lt;code&gt;append&lt;/code&gt; 的类型签名（当然！）。
最后，类型签名告诉我们 $rest$ 的类型为 $L^0(\alpha)$，所以构建最终返回结果 $x :: rest$ 也不需要往这个数据结构里面存势能了。&lt;/p&gt;
&lt;p&gt;我在&lt;a href=&#34;demo.pdf&#34;&gt;这份胶片&lt;/a&gt;里更详细地展示了这个带资源标注的类型系统。
需要特别提出的是，&lt;strong&gt;自动推导&lt;/strong&gt;这些数值标注并不困难：我们用变量来表示这些类型标注，那么类型检查就成为了生成关于这些变量的约束（通常是线性的）的过程，最后再解这些约束就好了。
在&lt;a href=&#34;https://www.raml.co/interface/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;这个页面&lt;/a&gt;上你可以和一个实现了自动均摊资源分析的工具（Resource-aware ML，RaML）玩耍，其主要贡献者也在今年发表了一篇还不错的综述&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;。
祝大家玩得愉快！&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://fbinfer.com/docs/checker-cost#examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://fbinfer.com/docs/checker-cost#examples&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://www.microsoft.com/en-us/research/publication/speed-precise-and-efficient-static-estimation-of-program-computational-complexity-2/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://www.microsoft.com/en-us/research/publication/speed-precise-and-efficient-static-estimation-of-program-computational-complexity-2/&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;Robert Tarjan. Amortized Computational Complexity. &lt;a href=&#34;https://doi.org/10.1137/0606031&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://doi.org/10.1137/0606031&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;Jan Hoffmann and Steffen Jost. Two decades of automatic amortized resource analysis. &lt;a href=&#34;https://doi.org/10.1017/S0960129521000487&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://doi.org/10.1017/S0960129521000487&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Easy Syntax Highlighting for LaTeX</title>
      <link>https://stonebuddha.github.io/post/easy-syntax-highlighting-for-latex/</link>
      <pubDate>Tue, 12 Jul 2022 04:56:22 +0800</pubDate>
      <guid>https://stonebuddha.github.io/post/easy-syntax-highlighting-for-latex/</guid>
      <description>&lt;p&gt;Tool link: &lt;a href=&#34;https://github.com/cpitclaudel/esh&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Emacs Syntax Highlighting for LaTeX (ESH)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The tool does not really require understanding Emacs: one just needs a working
installation!
The tool seems well tested on GNU/Linux; however, I am mainly using macOS, so I
find out an easy workflow that works for me.
First, we need to install &lt;a href=&#34;https://github.com/cask/cask&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cask&lt;/a&gt;, a project
management tool for Emacs; such process should be easy and straightforward.
Then we clone the &lt;code&gt;esh&lt;/code&gt; repo and run &lt;code&gt;cask build&lt;/code&gt; at the root of the repo.
If nothing goes wrong, we are now able to use ESH!&lt;/p&gt;
&lt;p&gt;Let us go to a LaTeX project where we want to highlight OCaml code.
First, we create a file &lt;code&gt;Cask&lt;/code&gt; with the following content:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-lisp&#34; data-lang=&#34;lisp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;gnu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;source&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;melpa&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;depends-on&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;tuareg&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;;; for OCaml mode&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then we run &lt;code&gt;cask install&lt;/code&gt; to install the required packages.
Now we start to configure how we would like our code to be highlighted.
We achieve this by creating a file &lt;code&gt;esh-init.el&lt;/code&gt;, and below gives an example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-lisp&#34; data-lang=&#34;lisp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;load-theme&lt;/span&gt; &lt;span class=&#34;ss&#34;&gt;&amp;#39;tango&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;;; a color theme&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;add-to-list&lt;/span&gt; &lt;span class=&#34;ss&#34;&gt;&amp;#39;auto-mode-alist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;\\.ml\\&amp;#39;&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;tuareg-mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;;; .ml file extension&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;;; some custom prettification&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;when&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;require&lt;/span&gt; &lt;span class=&#34;ss&#34;&gt;&amp;#39;tuareg&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;no&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;defun&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;my-tuareg-setup&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;setq-local&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;prettify-symbols-alist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;fun&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;?λ&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;-&amp;gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;?&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;→&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;prettify-symbols-mode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;add-hook&lt;/span&gt; &lt;span class=&#34;ss&#34;&gt;&amp;#39;tuareg-mode-hook&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;#&amp;#39;&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;my-tuareg-setup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Next, we run &lt;code&gt;./path/to/esh/bin/esh2tex --write-preamble&lt;/code&gt; to create a file &lt;code&gt;esh-preamble.tex&lt;/code&gt;.
The generated TeX file implements functions to highlight code in TeX.
Below presents an example LaTeX file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-latex&#34; data-lang=&#34;latex&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;\documentclass&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;{&lt;/span&gt;article&lt;span class=&#34;nb&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;\usepackage&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;[varqu]&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;{&lt;/span&gt;zi4&lt;span class=&#34;nb&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c&#34;&gt;% for inconsolata font
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;\input&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;{&lt;/span&gt;esh-preamble&lt;span class=&#34;nb&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;\begin&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;{&lt;/span&gt;document&lt;span class=&#34;nb&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;\ESHInputBlock&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;{&lt;/span&gt;test.ml&lt;span class=&#34;nb&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;\end&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;{&lt;/span&gt;document&lt;span class=&#34;nb&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;And an example OCaml code file &lt;code&gt;test.ml&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ocaml&#34; data-lang=&#34;ocaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;rec&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;append&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l1&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;match&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l1&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;with&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xs&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;rec&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;partition&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;match&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;with&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;partition&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xs&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;in&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;rec&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;quicksort&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;le&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;function&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;[]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;partition&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;le&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xs&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;in&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;append&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;quicksort&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;le&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;quicksort&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;le&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;zs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ESH needs to invoke Emacs to highlight the code and we have to perform this
external operation manually.
Fortunately, we just need to run &lt;code&gt;./path/to/esh/bin/esh2tex --standalone test.ml&lt;/code&gt;,
which should generate a file &lt;code&gt;test.ml.esh.tex&lt;/code&gt;.
Finally, we can typeset our LaTeX project (e.g, &lt;code&gt;pdflatex main&lt;/code&gt;) and should
get something similar to the following screenshot:
















&lt;figure  &gt;
  &lt;div class=&#34;d-flex justify-content-center&#34;&gt;
    &lt;div class=&#34;w-100&#34; &gt;&lt;img alt=&#34;&#34; srcset=&#34;
               /post/easy-syntax-highlighting-for-latex/example_hua9e26af124910f58e1d063b36d38f13c_133564_0c5bd0df2fcdfdd89c596ad0e0e753c5.webp 400w,
               /post/easy-syntax-highlighting-for-latex/example_hua9e26af124910f58e1d063b36d38f13c_133564_650d9435e24ada875e8a4ff9b448941d.webp 760w,
               /post/easy-syntax-highlighting-for-latex/example_hua9e26af124910f58e1d063b36d38f13c_133564_1200x1200_fit_q75_h2_lanczos_3.webp 1200w&#34;
               src=&#34;https://stonebuddha.github.io/post/easy-syntax-highlighting-for-latex/example_hua9e26af124910f58e1d063b36d38f13c_133564_0c5bd0df2fcdfdd89c596ad0e0e753c5.webp&#34;
               width=&#34;760&#34;
               height=&#34;665&#34;
               loading=&#34;lazy&#34; data-zoomable /&gt;&lt;/div&gt;
  &lt;/div&gt;&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;Amazing!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Semantics of Probabilistic Programs: An Algebraic Approach</title>
      <link>https://stonebuddha.github.io/talk/semantics-of-probabilistic-programs-an-algebraic-approach/</link>
      <pubDate>Sat, 12 Mar 2022 14:00:00 +0800</pubDate>
      <guid>https://stonebuddha.github.io/talk/semantics-of-probabilistic-programs-an-algebraic-approach/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Central Moment Analysis for Cost Accumulators in Probabilistic Programs</title>
      <link>https://stonebuddha.github.io/publication/wanghr21a/</link>
      <pubDate>Sun, 20 Jun 2021 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/publication/wanghr21a/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Sound Probabilistic Inference via Guide Types</title>
      <link>https://stonebuddha.github.io/publication/wanghr21b/</link>
      <pubDate>Sun, 20 Jun 2021 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/publication/wanghr21b/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Type-Guided Worst-Case Input Generation</title>
      <link>https://stonebuddha.github.io/talk/type-guided-worst-case-input-generation/</link>
      <pubDate>Thu, 03 Jun 2021 10:00:00 -0400</pubDate>
      <guid>https://stonebuddha.github.io/talk/type-guided-worst-case-input-generation/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Expected-Cost Analysis for Probabilistic Programs and Semantics-Level Adaption of Optional Stopping Theorems</title>
      <link>https://stonebuddha.github.io/publication/wanghr21c/</link>
      <pubDate>Tue, 30 Mar 2021 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/publication/wanghr21c/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Termination Analysis of Random Walks</title>
      <link>https://stonebuddha.github.io/post/termination-analysis-of-random-walks/</link>
      <pubDate>Mon, 15 Feb 2021 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/post/termination-analysis-of-random-walks/</guid>
      <description>&lt;p&gt;In this post, we consider one-dimensional random walks:
assume that $S_n = \sum_{i=1}^n X_i$ is a random walk on the integers with
initial value $S_0 = 0$, where $X_i, i \in \mathbb{N}$ are independent and
identically distributed random variables.
For termination analysis, we introduce a &lt;i&gt;stopping time&lt;/i&gt;: a nonnegative
integer-valued random variable $T$ such that for every integer $n \ge 0$, the
indicator function of the event $\lbrace T = n \rbrace$ is a function of
$S_1,S_2,\cdots,S_n$.&lt;/p&gt;
&lt;h2 id=&#34;symmetric-random-walk&#34;&gt;Symmetric Random Walk&lt;/h2&gt;
&lt;p&gt;For each $i \in \mathbb{N}$, we consider
$X_i = \left\lbrace \begin{array}{ll}  1 &amp;amp; \text{with prob.}~0.5 \\ -1 &amp;amp; \text{with prob.}~0.5 \end{array} \right.$.
Symmetric random walks are known to be &lt;em&gt;recurrent&lt;/em&gt;, i.e., with probability
one, any state is visited infinitely often.
Let us consider the case where the random walk terminates when it reaches the
level $1$, i.e., $T := \min\lbrace n \ge 0 : S_n = 1 \rbrace$, and $T$ is
clearly a stopping time.
How do we establish the recurrence property for $T$, i.e., $\mathbb{P}[T &amp;lt; \infty] = 1$?
Moreover, what can we say about $\mathbb{E}[T]$?&lt;/p&gt;
&lt;p&gt;One method is to derive $T$&amp;rsquo;s &lt;em&gt;probability generating function&lt;/em&gt;
$G(z) := \mathbb{E}[z^T] = \sum_{n=0}^{\infty} z^n \mathbb{P}[T=n]$,
which is defined for all real values of $z$ less than $1$ in absolute value.
The strategy for the derivation is to condition on the first step of the random
walk to obtain a functional equation for $G$; there are two possibilities:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if $X_1 = 1$, then $S_1 = 1$ and $T = 1$; or&lt;/li&gt;
&lt;li&gt;if $X_1 = -1$, then $S_1 = -1$, and the random walk must first return to the
origin, and the amount of time it takes to reach $0$ starting from $-1$ has the
same distribution as&amp;mdash;and is conditionally independent of&amp;mdash;$T$ itself (i.e.,
the amount of time to reach $1$ from $0$).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thus, $G(z) = 0.5z + 0.5z \cdot G(z) \cdot G(z) = (z + zG(z)^2) / 2$.
This is a functional equation, whose solution is $G(z) = (1 \pm \sqrt{1 - z^2})/z$.
Moreover, observing that $G(z)$ takes values between 0 and 1 when $z \in (0,1)$,
we obtain the unique solution $G(z) = (1 - \sqrt{1- z ^2})/z$.&lt;/p&gt;
&lt;p&gt;Then, by the monotone convergence theorem, we have
$$
\mathbb{P}[T &amp;lt; \infty] = \sum_{n=0}^\infty \mathbb{P}[T = n] = \lim_{z \to 1^-} G(z) = 1.
$$
Similarly, noting that $G&amp;rsquo;(z) = \sum_{n=1}^{\infty} n z^{n-1} \mathbb{P}[T=n]$,
we can express $\mathbb{E}[T]$ as $G&amp;rsquo;(1^-)$.
Because $G&amp;rsquo;(z) = (-1 + 1/\sqrt{1 - z^2})/z^2$,
we have $\mathbb{E}[T] = G&amp;rsquo;(1^-) = \infty$, i.e., the expected termination time is infinity.&lt;/p&gt;
&lt;h2 id=&#34;gamblers-ruin&#34;&gt;Gambler&amp;rsquo;s Ruin&lt;/h2&gt;
&lt;p&gt;Let us consider another termination criterion for symmetric random walks:
it is set up so that Alice and Bob bet one dollar against each other on the
results of a fair coin flip until one play runs out of money. Suppose that Alice
starts with $A$ dollars and Bob starts with $B$ dollars.
We define a termination time to model the gamble:
$T := \min\lbrace n \ge 0: S_n = -A \vee S_n = B\rbrace$, which is clearly a stopping time.
By a similar argument, we can show both $\mathbb{P}[T_A &amp;lt; \infty] = 1$
where $T_A := \min\lbrace n \ge 0: S_n = -A \rbrace$,
and $\mathbb{P}[T_B &amp;lt; \infty] = 1$ where $T_B := \min\lbrace n \ge 0: S_n = B\rbrace$.
Thus, we know that $\mathbb{P}[T &amp;lt; \infty] = 1$ as $T = \min(T_A,T_B)$.
But what about $\mathbb{E}[T]$ in this case?&lt;/p&gt;
&lt;p&gt;We use another technique called &lt;em&gt;Wald identities&lt;/em&gt;, two of which have the form below
in a random-walk setting:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If the step distribution has a finite first moment and the stopping
time has a finite expectation, then $\mathbb{E}[S_T] = \mathbb{E}[X_1]\mathbb{E}[T]$.&lt;/li&gt;
&lt;li&gt;If the step distribution has a finite second moment and the stopping
time has a finite expectation, then $\mathbb{E}[(S_T-\mathbb{E}[X_1]T)^2]=\mathbb{E}[(X_1-\mathbb{E}[X_1])^2]\mathbb{E}[T]$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let us assume $\mathbb{E}[T] &amp;lt; \infty$ first.
By the definition of $X_1$, we know that $\mathbb{E}[X_1] = 0$ and $\mathbb{E}[X_1^2]=1$.
By the first Wald identity, we have $\mathbb{E}[S_T]=0$.
The random variable $S_T$ takes only two values, $-A$ and $B$, with probabilities
$u$ and $1-u$ such that $u \cdot (-A) + (1-u) \cdot B = 0 \implies u = B/(A+B)$.
By the second Wald identity, we know that $\mathbb{E}[S_T^2]=\mathbb{E}[T]$.
Thus, we can compute $\mathbb{E}[T]$ from $S_T$&amp;rsquo;s distribution:
$ \frac{B}{A+B} \cdot (-A)^2 + \frac{A}{A+B} \cdot B^2 = A \cdot B$.&lt;/p&gt;
&lt;p&gt;To show $\mathbb{E}[T] &amp;lt; \infty$ at the first place, we observe that if at any
time during the gamble Alice wins consecutive $A+B$ rounds, then Bob must run out
of money and the gamble must terminate. Thus,
$$
\mathbb{P}[T &amp;gt; k(A+B)] \le (1 - \frac{1}{2^{A+B}})^k,
$$
and $\mathbb{E}[T] \le \sum_{k=0}^\infty (A+B)(1-\frac{1}{2^{A+B}})^k &amp;lt; \infty$.&lt;/p&gt;
&lt;h2 id=&#34;asymmetric-random-walk-uneven-steps&#34;&gt;Asymmetric Random Walk (Uneven Steps)&lt;/h2&gt;
&lt;p&gt;For each $i \in \mathbb{N}$, we consider
$X_i = \left\lbrace \begin{array}{ll}  2 &amp;amp; \text{with prob.}~0.5 \\ -1 &amp;amp; \text{with prob.}~0.5 \end{array} \right.$.
For the termination criterion, we define $T(m) := \min\lbrace n \ge 0 : S_n \ge m\rbrace$ for any positive integer $m$.
Let us fixed an $m$ and write $T = T(m)$.
This time, we do not argue that $\mathbb{P}[T &amp;lt; \infty] = 1$, but reason about $\mathbb{E}[T]$ directly.&lt;/p&gt;
&lt;p&gt;We want to construct a &lt;em&gt;martingale&lt;/em&gt; $\lbrace Y_n \rbrace_{n \in \mathbb{N}_0}$,
which is adapted to $\lbrace S_n \rbrace_{n \in \mathbb{N}_0}$, as follows:
$$ Y_n := n + 2(m+1 - S_n), n \in \mathbb{N}_0. $$
We can verify the martingale property by
$$
\begin{align}
&amp;amp; \mathbb{E}[Y_{n+1} \mid S_0,S_1,\cdots,S_n] \\
={} &amp;amp; n+1 + 2(m+1-S_n) - 2\mathbb{E}[X_{n+1} \mid S_0,S_1,\cdots,S_n] \\
={} &amp;amp; n+1 + 2(m+1-S_n) - 1 \\
={} &amp;amp; Y_n.
\end{align}
$$
Then the stopped process $\lbrace Y_{T \wedge n} \rbrace_{n \in \mathbb{N}_0}$ is a nonnegative
martingale, because $\mathbb{P}[S_n \le m + 1 \mid n \le T] = 1$.
Therefore, by Doob&amp;rsquo;s martingale convergence theorem, $Y_T := \lim_{n \to \infty} Y_{T \wedge n}$
is almost-surely well-defined and $\mathbb{E}[Y_T] \le \mathbb{E}[Y_0] = 2(m+1)$.
On the other hand, the random variable $S_T$ takes only two values, $m$ and $(m+1)$, so
we have $Y_T = T + 2(m+1-S_T) \ge T$, thus $\mathbb{E}[T] \le 2(m+1)$.&lt;/p&gt;
&lt;p&gt;To obtain an exact result for $\mathbb{E}[T]$, we can reason about the distribution
of $S_T$ (via recurrence solving) and apply the first Wald identity.
The result is $\mathbb{E}[T] = 2(m+1 - \frac{2}{1+\sqrt{5}}( 1 - (\frac{1-\sqrt{5}}{2})^{m+1} ) )$.&lt;/p&gt;
&lt;h2 id=&#34;asymmetric-random-walk-uneven-probabilities&#34;&gt;Asymmetric Random Walk (Uneven Probabilities)&lt;/h2&gt;
&lt;p&gt;For each $i \in \mathbb{N}$, we consider
$X_i = \left\lbrace \begin{array}{ll}  1 &amp;amp; \text{with prob.}~0.75 \\ -1 &amp;amp; \text{with prob.}~0.25 \end{array} \right.$.
For the termination criterion, we define $T(m) := \min\lbrace n \ge 0 : S_n = m\rbrace$ for any positive integer $m$.
This time, we want to reason about both $\mathbb{E}[T(m)]$ and $\mathbb{E}[T(m)^2]$.&lt;/p&gt;
&lt;p&gt;We can use the techniques in previous sections to derive that $\mathbb{P}[T(m) &amp;lt; \infty] = 1$
and $\mathbb{E}[T(m)] = 2m$.
For second (or even higher) moments, we can again use probability generating functions
$G_m(z) := \mathbb{E}[z^{T(m)}]$.
Observing that a random walk with the target level $m$ can be decomposed into $m$
independent random walks that reach $1$ starting from $0$,
we have $G_m(z) = G_1(z)^m$.
We follow the strategy that conditions on the first step of the random walk to obtain
a functional equation for $G_1(z)$; there are two possibilities:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if $X_1=1$, then $S_1=1$ and $T=1$; or&lt;/li&gt;
&lt;li&gt;if $X_1=-1$, then $S_1=-1$ and the problem can be reduced to reaching $2$ starting from $0$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Thus, $G_1(z) = 0.75z + 0.25z \cdot G_2(z) = 0.75z + 0.25zG_1(z)^2$.
The solution is $G_1(z) = (2 \pm \sqrt{4 - 3z^2})/z$.
Again, because $G_1(z)$ takes values between 0 and 1 when $z \in (0,1)$, we obtain the unique solution
$G_1(z) = (2-\sqrt{4-3z^2})/z$.&lt;/p&gt;
&lt;p&gt;Let us write $T = T(m)$.
By the property of probability generating functions, we have $\mathbb{E}[T(T-1)] = G_m&amp;rsquo;&amp;rsquo;(1^-) = 4m^2+4m$.
Therefore, $\mathbb{E}[T^2] = \mathbb{E}[T(T-1)] + \mathbb{E}[T] = 4m^2+6m$.&lt;/p&gt;
&lt;h2 id=&#34;whats-more&#34;&gt;What&amp;rsquo;s More&lt;/h2&gt;
&lt;p&gt;In &lt;a href=&#34;../../publication/wanghr21a&#34;&gt;our paper&lt;/a&gt;, we present a systematic and automated
framework for upper- and lower-bounding higher moments of cost accumulators (e.g., termination time)
in probabilistic programs (e.g., random walks).&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Type-Based Resource-Guided Search</title>
      <link>https://stonebuddha.github.io/talk/type-based-resource-guided-search/</link>
      <pubDate>Fri, 16 Oct 2020 12:00:00 -0400</pubDate>
      <guid>https://stonebuddha.github.io/talk/type-based-resource-guided-search/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Liquid Resource Types</title>
      <link>https://stonebuddha.github.io/publication/knothwr20/</link>
      <pubDate>Sun, 23 Aug 2020 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/publication/knothwr20/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Raising Expectations: Automating Expected Cost Analysis with Types</title>
      <link>https://stonebuddha.github.io/publication/wangkh20/</link>
      <pubDate>Sun, 23 Aug 2020 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/publication/wangkh20/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Resource-Guided Program Synthesis</title>
      <link>https://stonebuddha.github.io/talk/resource-guided-program-synthesis/</link>
      <pubDate>Fri, 22 Nov 2019 12:00:00 -0500</pubDate>
      <guid>https://stonebuddha.github.io/talk/resource-guided-program-synthesis/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Resource-Guided Program Synthesis</title>
      <link>https://stonebuddha.github.io/publication/knothwp19/</link>
      <pubDate>Sat, 22 Jun 2019 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/publication/knothwp19/</guid>
      <description></description>
    </item>
    
    <item>
      <title>A Denotational Semantics for Low-Level Probabilistic Programs with Nondeterminism</title>
      <link>https://stonebuddha.github.io/publication/wanghr19/</link>
      <pubDate>Mon, 03 Jun 2019 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/publication/wanghr19/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Type-Guided Worst-Case Input Generation</title>
      <link>https://stonebuddha.github.io/publication/wangh19/</link>
      <pubDate>Sun, 13 Jan 2019 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/publication/wangh19/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Using FFT to Speed Up DP</title>
      <link>https://stonebuddha.github.io/post/using-fft-to-speed-up-dp/</link>
      <pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/post/using-fft-to-speed-up-dp/</guid>
      <description>&lt;p&gt;Problem link: &lt;a href=&#34;https://www.hackerrank.com/challenges/counting-road-networks&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Counting Road Networks | HackerRank&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You are supposed to count the number of connected undirected labeled graphs with $n$ vertices.
Algorithms with $O(n \log^2 n)$ time complexity are preferable.&lt;/p&gt;
&lt;h2 id=&#34;a-dynamic-programming-algorithm&#34;&gt;A Dynamic-Programming Algorithm&lt;/h2&gt;
&lt;p&gt;Let $f(n)$ be the answer for $n$.
The first idea to compute $f(n)$ is subtracting the number of disconnected graphs from the total number.
The total number of size-$n$ graphs is $g(n) := 2^{\binom{n}{2}}$.
How to count the disconnected graphs?
Let&amp;rsquo;s consider the size $m$ of the connected component containing the vertex labeled with 1.
Since the graph is disconnected, $m$ cannot be $n$.
Then the number of disconnected graphs where the connected component containing vertex 1 is a certain one with size $m$ is exactly $f(m) \cdot g(n-m)$.
Now we have an $O(n^2)$-time dynamic-programming algorithm as follows.
$$
f(n) = g(n) - \sum_{m=1}^{n-1} \binom{n-1}{m-1} \cdot f(m) \cdot g(n - m)
$$&lt;/p&gt;
&lt;h2 id=&#34;expression-rearrangement&#34;&gt;Expression Rearrangement&lt;/h2&gt;
&lt;p&gt;If we unfold the binomial coefficients, we will have
$$
\frac{f(n)}{(n-1)!} = n \cdot \frac{g(n)}{n!} - \sum_{m=1}^{n-1} \frac{f(m)}{(m-1)!} \cdot \frac{g(n-m)}{(n-m)!}
$$
Let $F(n) := \frac{f(n)}{(n-1)!}$ and $G(n) := \frac{g(n)}{n!}$.
Moreover, let&amp;rsquo;s set $F(0)$ to $0$ and then we have
$$
F(n) = n \cdot G(n) - \sum_{m=0}^{n-1} F(m) \cdot G(n-m)
$$
Note that we already have a convolution-like term in the formula.&lt;/p&gt;
&lt;h2 id=&#34;an-optimization-based-on-fft&#34;&gt;An Optimization Based on FFT&lt;/h2&gt;
&lt;p&gt;We will use &lt;a href=&#34;https://en.wikipedia.org/wiki/Fast_Fourier_transform&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fast Fourier transform&lt;/a&gt; (FFT) as an $O(n \log n)$-time algorithm to compute convolution of length $n$.&lt;/p&gt;
&lt;p&gt;First of all, $G(n)$ are easy to compute so we can pre-process them.
Now we are going to use a divide-and-conquer scheme.
Let $solve(l,r)$ be a procedure that computes $F(n)$ for all $n \in [l,r)$.
In addition, we add the following invariant to this procedure:&lt;/p&gt;
&lt;p&gt;When invoking $solve(l,r)$, we already compute for each $n \in [l,r)$, the partial convolution $\sum_{m=0}^{l-1} F(m) \cdot G(n-m)$, and store them in $H(n)$.&lt;/p&gt;
&lt;p&gt;Then our algorithm proceeds as follows.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If $l+1=r$, we set $F(l)$ to $l \cdot G(l) - H(l)$.&lt;/li&gt;
&lt;li&gt;Otherwise, let&amp;rsquo;s invoke $solve(l,k)$ first where $k = \frac{l+r}{2}$, i.e., the middle point.
Now we already solve the first half of the problem.
To become able to invoke $solve(k,r)$ to complete the second half, we need to do something to maintain the invariant above.
In essence, we need to update
$$
H(n) \gets H(n) + \sum_{m=l}^{k-1} F(m) \cdot G(n-m)
$$
for each $n \in [k,r)$.
Here comes the chance for optimization.
What we really want to compute is the convolution of $F[l,k)$ and $G[0,r-l)$!
Let the convolution result be $C$ and indeed we have
$$
C(n) = \sum_{m=l}^{k-1}  F(m) \cdot G(n-m)
$$
for each $n \in [k,r)$.
After performing $H(n) \gets H(n) + C(n)$ for each $n \in [k,r)$, we reestablish the invariant and we can recurse to $solve(k,r)$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Finally, let&amp;rsquo;s estimate the time complexity of the algorithm above.
Let $T(n)$ be the running time of $solve(l,r)$ with $n=r-l$.
By using FFT to compute the convolution, we can establish the following
$$
T(n) = 2T(\frac{n}{2}) + O(n \log n)
$$
Then by the Master Theorem we derive that $T(n) = O(n \log^2 n)$.&lt;/p&gt;
&lt;h2 id=&#34;whats-more&#34;&gt;What&amp;rsquo;s More&lt;/h2&gt;
&lt;p&gt;For those who could read Chinese, &lt;a href=&#34;https://www.cs.princeton.edu/~danqic/misc/divide-and-conquer.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CDQ&amp;rsquo;s divide-and-conquer&lt;/a&gt; is a good reference about applications of the divide-and-conquer scheme in this post.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PMAF: An Algebraic Framework for Static Analysis of Probabilistic Programs</title>
      <link>https://stonebuddha.github.io/publication/wanghr18/</link>
      <pubDate>Wed, 20 Jun 2018 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/publication/wanghr18/</guid>
      <description></description>
    </item>
    
    <item>
      <title>PMAF: An Algebraic Framework for Static Analysis of Probabilistic Programs</title>
      <link>https://stonebuddha.github.io/talk/pmaf-an-algebraic-framework-for-static-analysis-of-probabilistic-programs/</link>
      <pubDate>Fri, 20 Apr 2018 12:00:00 -0400</pubDate>
      <guid>https://stonebuddha.github.io/talk/pmaf-an-algebraic-framework-for-static-analysis-of-probabilistic-programs/</guid>
      <description></description>
    </item>
    
    <item>
      <title>TiML: A Functional Language for Practical Complexity Analysis with Invariants</title>
      <link>https://stonebuddha.github.io/talk/timl-a-functional-language-for-practical-complexity-analysis-with-invariants/</link>
      <pubDate>Fri, 09 Feb 2018 12:00:00 -0500</pubDate>
      <guid>https://stonebuddha.github.io/talk/timl-a-functional-language-for-practical-complexity-analysis-with-invariants/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Nondeterministic Interpretation</title>
      <link>https://stonebuddha.github.io/post/nondeterministic-interpretation/</link>
      <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/post/nondeterministic-interpretation/</guid>
      <description>&lt;p&gt;Suppose you have a toy specification with built-in nondeterminism, and you want to generate answers with respect to the specification:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ocaml&#34; data-lang=&#34;ocaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;EInt&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;of&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;EPair&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;of&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ENdet&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;of&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exp&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;VInt&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;of&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;VPair&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;of&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For example, from the following specification&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ocaml&#34; data-lang=&#34;ocaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nc&#34;&gt;EPair&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;ENdet&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;EInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;EInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;ENdet&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;EInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;EInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;you might want to generate a bunch of possible answers:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ocaml&#34; data-lang=&#34;ocaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nc&#34;&gt;VPair&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;VInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;VInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nc&#34;&gt;VPair&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;VInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;VInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nc&#34;&gt;VPair&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;VInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;VInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nc&#34;&gt;VPair&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;VInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;VInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The scene might be where you want to specify something with multiple sites of nondeterminism, ask the generator to come up with an answer, and successively give you other answers until you are satisfied.&lt;/p&gt;
&lt;p&gt;The basic methodology is search.
We want to construct a recursive procedure on the structure of a specification.
For a sub-specification, it should know two sorts of computation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the computation that completes a whole answer and constructs a procedure for next whole answers, given the current sub-answer for the sub-specification and a procedure for next whole answers if the current sub-answer would leads to a subsequent unsatisfactoriness; and&lt;/li&gt;
&lt;li&gt;the computation to find next whole answers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this sense, the first computation has type $\mathsf{ans} \to \mathsf{next} \to \mathsf{ans} \times \mathsf{next}$, and the second one should be typed $\mathsf{next}$.
A computation of type $\mathsf{next}$ is supposed to (i) either fail, or (ii) take no arguments, and when invoked it should return the next whole answer as well as a new $\mathsf{next}$ computation.
Thus we have $\mathsf{next} \equiv \mathbf{1} + \mathbf{1} \to (\mathsf{ans} \times \mathsf{next})$.
Therefore we use recursive types to model this mechanism.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ocaml&#34; data-lang=&#34;ocaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;NFail&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;NCont&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;of&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ans&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then it is straightforward to implement an interpreter:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ocaml&#34; data-lang=&#34;ocaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;rec&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;interp&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exp&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cont&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fail&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;match&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exp&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;with&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;EInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cont&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;VInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fail&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;EPair&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;interp&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fail&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;interp&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&amp;#39;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fail&amp;#39;&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cont&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;VPair&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fail&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fail&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fail&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ENdet&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;e1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;interp&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e1&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cont&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;NCont&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;interp&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e2&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cont&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fail&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The execution should be the following:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ocaml&#34; data-lang=&#34;ocaml&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ans1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;interp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;EPair&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;ENdet&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;EInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;EInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;ENdet&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;EInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nc&#34;&gt;EInt&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;fun&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fail&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fail&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;NFail&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;(* val ans1 : ans = VPair (VInt 5, VInt 7) *)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;(* val next1 : next = NCont &amp;lt;fun&amp;gt; *)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ans2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;match&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next1&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;NCont&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;(* val ans2 : ans = VPair (VInt 5, VInt 8) *)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;(* val next2 : next = NCont &amp;lt;fun&amp;gt; *)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ans3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;match&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next2&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;NCont&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;(* val ans3 : ans = VPair (VInt 6, VInt 7) *)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;(* val next3 : next = NCont &amp;lt;fun&amp;gt; *)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ans4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;match&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next3&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;NCont&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;(* val ans4 : ans = VPair (VInt 6, VInt 8) *)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c&#34;&gt;(* val next4 : next = NFail *)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>TiML: A Functional Language for Practical Complexity Analysis with Invariants</title>
      <link>https://stonebuddha.github.io/publication/wangwc17/</link>
      <pubDate>Wed, 25 Oct 2017 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/publication/wangwc17/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Conditional Dyck-CFL Reachability Analysis for Complete and Efficient Library Summarization</title>
      <link>https://stonebuddha.github.io/publication/tangwx17/</link>
      <pubDate>Sat, 22 Apr 2017 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/publication/tangwx17/</guid>
      <description></description>
    </item>
    
    <item>
      <title>News Archive</title>
      <link>https://stonebuddha.github.io/news_archive/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/news_archive/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;[Sep 2021]&lt;/strong&gt; I am on the academic job market for 2022 positions. Please reach out to me if you think I would be a good fit for your department.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Feb 2021]&lt;/strong&gt; I am excited that our papers &lt;a href=&#34;publication/wanghr21b&#34;&gt;Sound Probabilistic Inference via Guide Types&lt;/a&gt; and &lt;a href=&#34;publication/wanghr21a&#34;&gt;Central Moment Analysis for Cost Accumulators in Probabilistic Programs&lt;/a&gt; with Jan and Tom have been conditionally accepted to PLDI 2021.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Nov 2020]&lt;/strong&gt; Our technical report about &lt;a href=&#34;https://arxiv.org/pdf/2011.09037&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Probabilistic Resource-Aware Session Types&lt;/a&gt; is available on arXiv.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Jun 2020]&lt;/strong&gt; Our articles &lt;a href=&#34;../publication/knothwr20&#34;&gt;Liquid Resource Types&lt;/a&gt; and &lt;a href=&#34;../publication/wangkh20&#34;&gt;Raising Expectations: Automating Expected Cost Analysis with Types&lt;/a&gt; have been accepted to ICFP 2020.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[May 2019]&lt;/strong&gt; Check out our recent MFPS paper on &lt;a href=&#34;../publication/wanghr19&#34;&gt;A Denotational Semantics for Low-Level Probabilistic Programs with Nondeterminism&lt;/a&gt; with Jan and Tom.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Feb 2019]&lt;/strong&gt; Great news: Our paper on &lt;a href=&#34;../publication/knothwp19&#34;&gt;Resource-Guided Program Synthesis&lt;/a&gt; has been conditionally accepted to PLDI 2019.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Nov 2018]&lt;/strong&gt; I am excited that our paper &lt;a href=&#34;../publication/wangh19&#34;&gt;Type-Guided Worst-Case Input Generation&lt;/a&gt; with Jan Hoffmann has been accepted to POPL 2019.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Mar 2018]&lt;/strong&gt; Check out my talent show &lt;a href=&#34;https://www.youtube.com/watch?v=zNxltZhPIG0&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Chengdu&lt;/a&gt; on SCS Day 2018!&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Feb 2018]&lt;/strong&gt; I am excited that our paper &lt;a href=&#34;../publication/wanghr18&#34;&gt;PMAF: An Algebraic Framework for Static Analysis of Probabilistic Programs&lt;/a&gt; (with Jan Hoffmann and Tom Reps) has been conditionally accepted to PLDI 2018.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;[Jun 2017]&lt;/strong&gt; I graduated from Peking University! My diploma thesis is about &lt;a href=&#34;../files/wang17thesis.pdf&#34;&gt;Accelerating Program Analyses by Conditional Summarization with Datalog&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Resources for Prospective Students</title>
      <link>https://stonebuddha.github.io/prospective-students/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/prospective-students/</guid>
      <description>&lt;p&gt;&lt;strong&gt;(Last updated on Oct 2, 2023)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I am broadly interested in topics related to programming languages, especially
formal verification, program analysis, and probabilistic programming.
I am currently working on resource-safe system programming, programmable
Bayesian inference, quantitative program analysis, and proof-oriented
programming languages.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you want to learn about possible projects and research directions that I
would like to advise or collaborate on at the moment, check out the &lt;a href=&#34;#current-research-directions&#34;&gt;list&lt;/a&gt; below.&lt;/li&gt;
&lt;li&gt;If you want to know more about my long-term perspectives of &lt;strong&gt;incorporating
randomness in software&lt;/strong&gt;, check out my
&lt;a href=&#34;https://stonebuddha.github.io/files/research.pdf&#34; target=&#34;_blank&#34;&gt;research statement&lt;/a&gt;
that I wrote for my faculty applications.&lt;/li&gt;
&lt;li&gt;If you care about teaching and mentoring, check out my
&lt;a href=&#34;https://stonebuddha.github.io/files/teaching.pdf&#34; target=&#34;_blank&#34;&gt;teaching statement&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;If you have concrete questions about me or Peking University, check out the
&lt;a href=&#34;#qa&#34;&gt;Q&amp;amp;A&lt;/a&gt; below, and send me an email if your question is not covered there.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;qa&#34;&gt;Q&amp;amp;A&lt;/h1&gt;
&lt;details open class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Are you recruiting students?&lt;/summary&gt;
  &lt;div style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
  &lt;b&gt;Yes&lt;/b&gt;!
  I am just getting started and planning to ramp up slowly (one to two PhD student a year).
  I am also looking for self-motivated master and undergraduate students.
  &lt;/div&gt;
&lt;/details&gt;
&lt;details open class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;
  Do I need to have a &lt;em&gt;specific&lt;/em&gt; research background?
  Do I need to know a &lt;em&gt;specific&lt;/em&gt; problem to work on?
  &lt;/summary&gt;
  &lt;div style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
  The short answer is &#34;&lt;b&gt;no&lt;/b&gt;.&#34;
  Programming-languages or software-engineering research experience would be a plus but &lt;b&gt;not a requisite&lt;/b&gt;.
  It is more important to know what you are interested in and be passionate enough about
  a broad area of problems to spend about four to five years to work on.
  &lt;/div&gt;
&lt;/details&gt;
&lt;details open class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Can I do machine learning / operating systems / database / ...?&lt;/summary&gt;
  &lt;div style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
  &lt;b&gt;Yes&lt;/b&gt;, if you are interested in the intersection of programming languages and the other field.
  Check out these interdisciplinary workshops:
  &lt;a href=&#34;https://mapsworkshop.github.io/&#34;&gt;Symposium on Machine Programming&lt;/a&gt;,
  &lt;a href=&#34;https://popl23.sigplan.org/home/lafi-2023&#34;&gt;Workshop on Languages for Inference&lt;/a&gt;,
  &lt;a href=&#34;https://plos-workshop.org/2023/&#34;&gt;Workshop on Programming Languages and Operating Systems&lt;/a&gt;,
  and
  &lt;a href=&#34;https://sites.google.com/view/dbpl2021&#34;&gt;Symposium on Database Programming Languages&lt;/a&gt;.
  &lt;/div&gt;
&lt;/details&gt;
&lt;details open class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Why should I consider Peking University? Who else could I work with at Peking University?&lt;/summary&gt;
  &lt;div style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
  Peking University has a world-class Computer Science Department (#14 according to
  &lt;a href=&#34;https://csrankings.org/#/index?all&amp;world&#34;&gt;CSRankings (2013-2023)&lt;/a&gt;
  and #19 according to
  &lt;a href=&#34;https://www.topuniversities.com/university-rankings/university-subject-rankings/2023/computer-science-information-systems&#34;&gt;QS Rankings (2023)&lt;/a&gt;).
  We have a large department with many amazing faculty and students working on software
  engineering, programming languages, systems, and other areas.
  Check out the following professors and their students, in last-name alphabetical order:
  &lt;a href=&#34;http://sei.pku.edu.cn/~haod&#34;&gt;Hao, Dan&lt;/a&gt;;
  &lt;a href=&#34;https://zhenjiang888.github.io/&#34;&gt;Hu, Zhenjiang&lt;/a&gt;;
  &lt;a href=&#34;https://taoxiease.github.io/&#34;&gt;Xie, Tao&lt;/a&gt;;
  &lt;a href=&#34;https://xiongyingfei.github.io/&#34;&gt;Xiong, Yingfei&lt;/a&gt;;
  &lt;a href=&#34;http://sei.pku.edu.cn/~zhanglu&#34;&gt;Zhang, Lu&lt;/a&gt;; and
  &lt;a href=&#34;https://xinpl.github.io/&#34;&gt;Zhang, Xin&lt;/a&gt;.
  &lt;/div&gt;
&lt;/details&gt;
&lt;details open class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;You did not reply to my email!&lt;/summary&gt;
  &lt;div style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
  &lt;b&gt;Please wait for one week, then resend it.&lt;/b&gt;
  &lt;/div&gt;
&lt;/details&gt;
&lt;h1 id=&#34;current-research-directions&#34;&gt;Current Research Directions&lt;/h1&gt;
&lt;p&gt;I always welcome new collaborators on the following (incomprehensive) list of research topics.
Please contact me if you are interested in working on one of those directions.&lt;/p&gt;
&lt;h3 id=&#34;resource-safe-system-programming&#34;&gt;Resource-Safe System Programming&lt;/h3&gt;
&lt;p&gt;Resource usage (e.g., time, memory, and energy) of a program is one of the central
subjects of computer science. However, resource usage usually does not play a central
role in programming language theory such as formal semantics, static analysis,
type systems, and program logics. I am generally interested in most resource-analysis
projects, including both verification (e.g., of software implemented in an existing
programming language) and language design (e.g., for easier and more precise resource analysis).&lt;/p&gt;
&lt;p&gt;Analysis of resource usage becomes increasingly critical for system programming.
The recent success of Rust indicates that modern system programming languages should
focus on static safety guarantees, such as memory safety and thread safety.
There are a lot of programming languages that do provide such guarantees, but
mostly via runtime mechanisms (such as garbage collection), and those mechanisms
result in unsatisfactory performance, especially in system software.
Rust, by proposing a memory-safety type system, reduces runtime resource consumption
and thus achieves high performance.
&lt;strong&gt;The performance of system software does not only involve memory management, though.&lt;/strong&gt;
I am interested in proposing a paradigm of &lt;strong&gt;resource-safe programming&lt;/strong&gt;, where
resource consumption of programs are statically verified to meet developers&amp;rsquo; expectation,
and the programs do not exhibit multiple kinds of resource-related vulnerabilities,
such as algorithmic complexity attacks and side-channel attacks.
Below is a sample of medium- to long-term projects of resource-safe system programming:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Resource analysis of Rust&lt;/em&gt;: Can the fine-grained memory model improve the precision
and efficiency of resource analysis?&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Resource analysis of concurrent programs&lt;/em&gt;: Rust has limited support for static thread-safety
guarantees, e.g., Rust does not statically rule out deadlocks. Can we incorporate fine-grained
concurrency model in system programming and extend resource analysis to support it?&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Target-level resource analysis&lt;/em&gt;: How can we analyze compiled programs with respect to
low-level resource metrics, e.g., the number of clock cycles? The analysis needs to be hardware-specific
because we need to take cache, pipeline, branch prediction, etc. into consideration.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Discovery of resource-related security vulnerabilities&lt;/em&gt;: Can we detect algorithmic-complexity-attack
bugs and/or side-channel-attack bugs? In addition, if such bugs exist, can we automatically
synthesize an attacker to trigger the bugs?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;At the moment, my favored approach is Automatic Amortized Resource Analysis (AARA&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;)
but I am open to other approaches such as recurrence solving, sized types, ranking functions,
symbolic resource analysis, etc.&lt;/p&gt;
&lt;h3 id=&#34;programmable-bayesian-inference&#34;&gt;Programmable Bayesian Inference&lt;/h3&gt;
&lt;p&gt;In contrast to frequentist methods like deep learning, Bayesian learning accounts
for the probability distribution of hypotheses that produce the observed data and thus
naturally quantifies the uncertainty that is present in the learned models.
In addition, Bayesian learning enables the straightforward incorporation of domain
knowledge and generalizes well to unseen data. These advantages of Bayesian learning
are realized by probabilistic programming languages (PPLs) like &lt;a href=&#34;https://mc-stan.org/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Stan&lt;/a&gt; and &lt;a href=&#34;http://pyro.ai/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Pyro&lt;/a&gt;,
which provide an interface that separates model development from various built-in
Bayesian inference algorithms.&lt;/p&gt;
&lt;p&gt;The main downside of Bayesian learning is that probabilistic inference is computationally hard
and not even the most advanced inference algorithms work well for all models.
To make probabilistic inference for Bayesian learning feasible for more models and larger data sets,
some PPLs have there forgone the strict separation of modeling and inference by enabling users to customize
specific Bayesian inference algorithms through so-called &lt;strong&gt;programmable inference&lt;/strong&gt;&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;.
However, it is all too easy for users to incorrectly program inference in a way that
breaks convergence and leads to unsound learned models. Such a mistake can even go unnoticed.&lt;/p&gt;
&lt;p&gt;I am interested in dissipating the tension between soundness and flexibility of
probabilistic inference by applying programming language techniques such as type
systems and static analysis. The vision is that new programming abstractions and
type systems ensure the soundness of programmable inference while static analysis
and program synthesis assist users by automating the customization of inference
with to goal of improving efficiency. Our &lt;a href=&#34;https://stonebuddha.github.io/publication/wanghr21b&#34; target=&#34;_blank&#34;&gt;PLDI paper&lt;/a&gt;
is a concrete demonstration of this research direction.&lt;/p&gt;
&lt;h3 id=&#34;quantitative-program-analysis&#34;&gt;Quantitative Program Analysis&lt;/h3&gt;
&lt;p&gt;Randomness in programs can show up in two ways: external randomness (e.g.,
uncertainty from the environment) and internal randomness (e.g., randomized algorithms).
As Kleene algebras become an algebraic foundation for analysis of non-probabilistic programs&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;,
I am interested in developing an algebraic framework for analysis of probabilistic programs.
To this end, we need to formulate an algebraic semantic framework of probabilistic programs,
and develop a generic algorithm to solve program-analysis instances for probabilistic programs.&lt;/p&gt;
&lt;p&gt;One fundamental difference between non-probabilistic and probabilistic programs
is that an execution of a non-probabilistic program is a &lt;strong&gt;chain&lt;/strong&gt;, but an execution
of a probabilistic program is a &lt;strong&gt;tree&lt;/strong&gt;.
To see the point, consider that our program model allows nondeterminism.
A non-probabilistic program then corresponds to a collection of possible execution chains,
but a probabilistic program should be interpreted as a &lt;strong&gt;collection of distributions&lt;/strong&gt;,
each of which can be encoded as an execution tree, where each rooted path (annotated with
a probability) is a concrete run of the program.
See our &lt;a href=&#34;https://stonebuddha.github.io/publication/wanghr19&#34; target=&#34;_blank&#34;&gt;MFPS paper&lt;/a&gt; for
a more formal presentation based on &lt;em&gt;hyper graphs&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Abstract interpretation is a powerful framework for describing and solving program-analysis
instances.
Researchers have proposed generic solving strategies, such as chaotic iteration, widening, narrowing, etc.
&lt;strong&gt;However, the iterative solving algorithms do not fit into the quantitative nature
of probabilistic programs.&lt;/strong&gt;
Suppose we want to analyze a probabilistic loop &amp;ldquo;$\mathbf{while}~(\mathbf{prob}(3/4))~\{ x = x + 1; \}$.&amp;rdquo;
The expected delta of the variable $x$ is the least solution to the equation $r = f(r) \equiv (1/4) \cdot 0+(3/4) \cdot (r+1)$,
and we can analytically solve it directly: $r = 3$.
However, an iterative solving strategy would approach $r$ by a sequence of approximations: $\{ f^i(0) \}_{i \in \mathbb{N}}$,
which will not converge in any finite number of iterations.
I am interested in adapting &lt;em&gt;Newtonian Program Analysis&lt;/em&gt;&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; to the probabilistic setting, with the observation
that Newton&amp;rsquo;s method is more suitable for such a quantitative setting.&lt;/p&gt;
&lt;p&gt;Moreover, the proposed algebraic framework of reasoning about probabilistic programs
should, in principle, be also suitable for reasoning about other quantitative properties,
such as &lt;strong&gt;resource consumption&lt;/strong&gt;.
It would be interesting be see if this observation leads to a more general quantitative
program analysis framework.
A recent paper by Batz et al. proposed a notion of &lt;em&gt;weighted programming&lt;/em&gt;&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;, which
further generalizes the quantitative properties.
Applications of the proposed quantitative program analysis framework include
technology transfer between probabilistic analysis and resource analysis; for example,
Maximum-a-Posteriori (MAP) estimation has a very
similar problem statement to Worst-Case Analysis (WCA), so it would be interesting to
use the observation to build new statistical resource analysis techniques.&lt;/p&gt;
&lt;!-- ### Proof-Oriented Programming Languages --&gt;
&lt;h1 id=&#34;other-projects&#34;&gt;Other Projects&lt;/h1&gt;
&lt;p&gt;I am always open to new directions, including interdisciplinary ones.
Below is a sample of initial ideas that I am interested in exploring in the
short (or medium) term.
The list is not complete, and be aware that most of the thoughts are not
matured at all; in fact, I would expect some of them will quickly lead to
negative results.&lt;/p&gt;
&lt;h3 id=&#34;static-analysis&#34;&gt;Static Analysis&lt;/h3&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Library Summarization via Tensor Products&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Library summarization is an effective way to accelerate the
analysis of client code. However, information about the client is unknown
at the library summarization, preventing complete summarization of the library.
A state-of-the-art approach is &lt;a href=&#34;https://stonebuddha.github.io/publication/tangwx17&#34; target=&#34;_blank&#34;&gt;Conditional Dyck-CFL Reachability Analysis (ConCRA)&lt;/a&gt;,
which targets graph-reachability-like static analyses and uses hypothetical summaries.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: Lal et al.&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt; proposed a tensor-product principle: Tensor products
with an appropriate detensor operation allow computations to be rearranged in
certain ways; for example, they can be used to delay a multiplication in a chain
of multiplications. This principle may allow us to generalize, in the summarization framework,
Dyck-CFL-reachability-based analyses to algebraic semiring-based analysis.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: The library summarization problem can be generalized to partially solving
an equation system for a static analysis. Any thoughts on partial evaluation?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;NPA-TP for Non-idempotent Semirings&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Esparza et al.&lt;sup id=&#34;fnref1:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; generalized Newton&amp;rsquo;s method to a method for finding
fixed-points of systems of equations over semirings, leading to a new algorithm
to solve interprocedural dataflow analysis.
Reps et al.&lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt; developed NPA-TP, which extended Esparza&amp;rsquo;s framework with an improved
algorithm for solving linear-context-free-language (LCFL) sub-problems.
However, NPA-TP assumes the underlying abstract domain admits an idempotent semiring;
such an assumption rules out interesting analysis domains, especially for numerical
properties, e.g., the reaching probability.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: Esparza&amp;rsquo;s original framework does support non-idempotent semirings,
so it would be a good starting point. The NPA-TP framework features tensor products
to solve LCFL sub-problems, and from the perspective of algebras, the principle of
tensor products does not require idempotence.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: Some recent work shows that quantum computation also needs
non-idempotent semirings. Can the idea of NPA-TP be generalized to analyze
quantum programs?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Complicated Probability Manipulation&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: In many programs, the manipulation of probability is very complicated
and even manual analysis of their correctness is difficult. Consider the problem below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;prob&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We want to verify that at the end of the loop, the probability of the event $x \ge \frac{1}{2}$
is exactly $p$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: &lt;a href=&#34;https://en.wikipedia.org/wiki/Probability-generating_function&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Probability-generating functions&lt;/a&gt; provide a succinct
way to describe probability distributions of discrete random variables.
We might try to derive the probability-generating function of a probabilistic program to
reason about the resulting distribution of the program.
A recent paper&lt;sup id=&#34;fnref:8&#34;&gt;&lt;a href=&#34;#fn:8&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;8&lt;/a&gt;&lt;/sup&gt; is on this direction.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: There is a connection between derivatives of the probability-generating function of
a random variable $X$ and the moments of $X$. Can we use the fact to perform moment analysis?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Fine-grained Heap Abstraction via Regular Patterns&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Static analysis of heap-manipulation programs often involves
heap sensitivity. In the simplest case, all memory allocations with the same
program location are treated as a single allocation (thus in a context-insensitive way).
Advanced techniques include three-value-logic for shape analysis, $k$-CFA, $m$-CFA&lt;sup id=&#34;fnref:9&#34;&gt;&lt;a href=&#34;#fn:9&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;9&lt;/a&gt;&lt;/sup&gt;, etc.
However, they seem insufficient when we want to analyze recursive programs.
(Imagine that in functional programming, iterating over a list is usually implemented as a
recursive function.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: We can treat the set of all call-strings as a language, then
different strategies for handling sensitivity are essentially different ways of
defining equivalence classes on the language. A presumably good proposal is to use
regular patterns to classify equivalence classes.
For example, $(ff)^*$ indicates calling a function $f$ for an even number of times,
$f(ff)^*$ for an odd number.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: In fact, this approach should generalize to all sensitivities that
use call strings. Is it meaningful to develop a general framework with regular-pattern-sensitivity?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;h3 id=&#34;formal-semantics&#34;&gt;Formal Semantics&lt;/h3&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Combination of Continuous Distributions and Nondeterminism-first&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: &lt;a href=&#34;https://stonebuddha.github.io/publication/wanghr19&#34; target=&#34;_blank&#34;&gt;Nondeterminism-first&lt;/a&gt; means that we resolve nondeterminism prior to
program inputs when defining denotational semantics. For example, suppose that a
deterministic function has the signature $A \to B$, then a standard resolution of
nondeterminism gives us $A \to \wp(B)$, but nondeterminism-first suggests $\wp(A \to B)$.
Nondeterminism-first can be useful for e.g., compile-time nondeterminism.
A recent study proposed a denotational semantics for probabilistic programs
that combines discrete distributions (on a countable state space) and nondeterminism-first.
However, it remains open if the semantics can be extended to support continuous distributions.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: In fact, I do not have any ideas yet.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: What about a computational theory for such a combination?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Combination of Probability and Message-passing Concurrency&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: The common treatment of a probabilistic flip in the semantics
is to &amp;ldquo;split&amp;rdquo; the current program configuration into two, one for the &amp;ldquo;world&amp;rdquo; where
the flip shows heads and the other for tails. When we need to deal with multiple
concurrent processes, such a treatment means a local flip in a process results in
duplicating all other processes. Such a non-local (thus non-compositional) behavior has been shown to be
problematic for proving soundness of formal methods (e.g., type systems, which are usually compositional).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: The result of a probabilistic flip should remain as local as possible.
We have recently developed &lt;a href=&#34;https://stonebuddha.github.io/publication/daswh20&#34; target=&#34;_blank&#34;&gt;an operational semantics with the desirable locality&lt;/a&gt;, but I feel that
a more algebraic representation is better. For example, we might want to rearrange
the operational semantics to reduction rules and congruence rules. Furthermore, we
should prove an equivalence result to the ordinary probabilistic semantics (e.g., Markov chains).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: I can always imagine that adding nondeterminism causes a lot of troubles.&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Building a Framework for Nondeterminism-as-refinement&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Nondeterminism is often referred to as the basis of
abstraction and refinement in the setting of stepwise developement&lt;sup id=&#34;fnref:10&#34;&gt;&lt;a href=&#34;#fn:10&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;10&lt;/a&gt;&lt;/sup&gt;.
However, such a pattern has not been popular in modern programming languages.
What is the main obstable for developing such a framework? Also, people have
developed many kinds of semantics for nondeterminism. Which semantics should be the
most suitable one for refinement-based programming and reasoning?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: I guess this has something to do with relational Hoare Logics&lt;sup id=&#34;fnref:11&#34;&gt;&lt;a href=&#34;#fn:11&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;11&lt;/a&gt;&lt;/sup&gt;.
At least they provide a way to use nondeterminism in a formal framework of proving
program properties.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: How to devise a language design for it?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;h3 id=&#34;type-systems&#34;&gt;Type Systems&lt;/h3&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Safe Interaction between Typed Domain Specific Languages&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Consider we have a typed programming language that is suitable for developing
embedded Domain Specific Languages (eDSLs).
Every eDSL can directly use the base type system from the host language, but it can
also have its own advanced domain-specific type system.
Languages such as &lt;a href=&#34;https://okmij.org/ftp/ML/MetaOCaml.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MetaOCaml&lt;/a&gt; have already supported
such a mechanism, but the interaction between the host language and the eDSL,
or maybe even between different eDSLs, is not very convenient yet.
It would be nice to have a simple and safe interaction scheme among eDSLs on
a same host language.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: In fact, I do not have any ideas yet.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: What else should we have for such a flexible eDSL framework? For example,
we might want to consider multi-stage compilation, debugger, mixed paradigm, etc.&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Lightweight Shape Check for Array Programming&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Array programming (or tensor programming) is pervasive nowadays because of machine learning.
Many machine-learning frameworks lack the ability to statically check tensor shapes are always consistent
during program execution. Approaches based on dependent/refinement/indexed types all seem too heavy to
become practical.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: In many (really?) cases, when the input of an array program is fixed,
the shapes of all intermediate arrays are also fixed. So we can perform a static shape check
after the input is given, but before we execute the program, by propagating the concrete shape information
from the given input.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: Is it possible to automatically learn the shape-related effects of library functions (e.g., &lt;code&gt;broadcast_tensor&lt;/code&gt;)?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Integration of Refinement Types and Separation Logic&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Recently, people have developed verification systems, e.g., CN&lt;sup id=&#34;fnref:12&#34;&gt;&lt;a href=&#34;#fn:12&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;12&lt;/a&gt;&lt;/sup&gt; and RefinedC&lt;sup id=&#34;fnref:13&#34;&gt;&lt;a href=&#34;#fn:13&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;13&lt;/a&gt;&lt;/sup&gt;,
which integrate refinement types and separtion logic to reason about low-level
programs. In those systems, refinements seem to still encode purely functional
properties (really?). How about enabling type refinements to be separation-logic
propositions? To that end, such refined types are not structural any more and
we need to work with substructural refinemend types. Does the integration make sense?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: It seems that we can start from linear refinement types.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: Linear typing and separation logic share a lot of similarities.
Are both rooted back in linear logic? If not, what is the fundamental difference?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Liquid-type-style Dijkstra Monads&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Dijkstra monads&lt;sup id=&#34;fnref:14&#34;&gt;&lt;a href=&#34;#fn:14&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;14&lt;/a&gt;&lt;/sup&gt; were originally proposed to automate
the verification-condition-generation (VCG) routine for analyzing effectful higher-order
programs. They later form the basis of F*, a proof-oriented programming language&lt;sup id=&#34;fnref:15&#34;&gt;&lt;a href=&#34;#fn:15&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;15&lt;/a&gt;&lt;/sup&gt;.
One feature of F* is that it supports proof-irrelevant refinement types.
Liquid types&lt;sup id=&#34;fnref:16&#34;&gt;&lt;a href=&#34;#fn:16&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;16&lt;/a&gt;&lt;/sup&gt; provide another method of balancing between automatic
type inference and dependent typing.
One main idea of liquid types is to separately design a language for specification.
Can we combine Dijkstra monads and liquid types? What are the benefits&amp;mdash;if there are&amp;mdash;to do this?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: So the system is basically a comination of liquid-style language design
and an F*-style type inference.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: Dijkstra monads support multi-monadic effects in a systematic way.
This means we might have a method to extend our &lt;a href=&#34;https://stonebuddha.github.io/publication/knothwr20&#34; target=&#34;_blank&#34;&gt;ICFP paper&lt;/a&gt;
to include the value interpretation as in the language itself.&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;h3 id=&#34;resource-analysis&#34;&gt;Resource Analysis&lt;/h3&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Fraction Bounds for Expected Cost Analysis&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Most of current resource-analysis techniques derive linear, polynomial,
or exponential bounds. However, when analyzing probabilistic programs, we often
encounter bounds that involve fractions. For example, the simple loop &lt;code&gt;while (prob(p)) tick(1);&lt;/code&gt;
has an expected cost of $\frac{p}{1-p}$, where $p$ is a program variable that denotes
a non-trivial probability.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: In many cases, a fraction bound can be expressed as a polynomial
over another polynomial. So it should be possible to extend current template-based
resource-analysis techniques (e.g., AARA) that derive polynomial bounds, by using
a template for the denominator to reduce fraction-bound inference to polynomial-bound
inference.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: A random thought: how can we apply such resource-analysis technique
to Bayesian inference (like a recent paper by Beutner et al.&lt;sup id=&#34;fnref:17&#34;&gt;&lt;a href=&#34;#fn:17&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;17&lt;/a&gt;&lt;/sup&gt;)?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;AARA for Probabilistic Functional Programs with Non-monotone Resources&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Our &lt;a href=&#34;https://stonebuddha.github.io/publication/wangkh20&#34; target=&#34;_blank&#34;&gt;ICFP paper&lt;/a&gt; presents
an extension of AARA that infers upper bounds on the expected cost of probabilistic functional
programs with monotone resources (such as time). In general, combining probability
and non-monotone resources (such as memory) is unreasonably complex&lt;sup id=&#34;fnref:18&#34;&gt;&lt;a href=&#34;#fn:18&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;18&lt;/a&gt;&lt;/sup&gt;. Applying optional stopping
theorems, people have successfully developed techniques for analyzing arithmetic programs.
It would be interesting to see if the whole methodology applies to functional programming,
where we have inductive data structures (that can hold potential) instead of numbers.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: One version of optional stopping theorems states that the expected change
in one evaluation step should be &amp;ldquo;bounded.&amp;rdquo; This should intuitively hold for
functional programming (I mean, in most cases) because one step should change the
size of a data structure by at most one (consider the case of &lt;code&gt;cons&lt;/code&gt;).
By constructing a suitable Markov chain, we might be able to reason about
probabilistic functional programs with non-monotone resources.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: Optional stopping theorems always talk about &amp;ldquo;expected change&amp;rdquo;
and &amp;ldquo;expected termination time.&amp;rdquo; Why them?!&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Newtonian Resource Analysis&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Apply the Newtonian Program Analysis (NPA) framework&lt;sup id=&#34;fnref2:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt; and its extension&lt;sup id=&#34;fnref1:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;
to carray out resource analysis.
Existing work has shown the possibility to perform recurrence-based analysis&lt;sup id=&#34;fnref:19&#34;&gt;&lt;a href=&#34;#fn:19&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;19&lt;/a&gt;&lt;/sup&gt;.
How about other kinds of resource analysis, like AARA?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: Because amortized analysis is naturally two-vocabulary, it seems possible
to recast AARA as a two-vocabulary abstract domain. The gap is that AARA is constraint-based,
which differs from the general NPA framework.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: NPA basically provides a framework for analyzing non-linear-recursive
programs by iteratively analyzing linear-recursive programs. Can we combine this idea
to iteratively use AARA to solve linear recursion?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;h3 id=&#34;probabilistic-programming&#34;&gt;Probabilistic Programming&lt;/h3&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Domain-specific Procedural Design&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: &lt;a href=&#34;https://dritchie.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Daniel Ritchie&lt;/a&gt; suggested generative
probabilistic programming for procedural modeling and design (the use of random programs
to generate visual content with respect to aesthetic or functional constraints).
Such an approach has been rediscovered in several individual developments, such as
Scenic&lt;sup id=&#34;fnref:20&#34;&gt;&lt;a href=&#34;#fn:20&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;20&lt;/a&gt;&lt;/sup&gt; and Picture&lt;sup id=&#34;fnref:21&#34;&gt;&lt;a href=&#34;#fn:21&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;21&lt;/a&gt;&lt;/sup&gt;. So instead of separate developments,
we want to develop a framework to ease such domain-specific procedural design.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: This has something to do with the eDSL framework.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: It might be interesting to see how such &lt;strong&gt;static&lt;/strong&gt; procedural design
evolves to &lt;strong&gt;dynamic&lt;/strong&gt; procedural design (e.g., synthesis of an environment).
Another direction is interactive refinement (e.g., incorporating feedbacks from users)
of the generated designs.&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Language Design for Sound Involutive MCMC&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: A recent paper by Cusumano-Towner et al.&lt;sup id=&#34;fnref:22&#34;&gt;&lt;a href=&#34;#fn:22&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;22&lt;/a&gt;&lt;/sup&gt; studies
how to ease the burden of implementing involutive MCMC by combining probabilistic
programming and differentiable programming. It still remains a challenge (emm, you have to double check)
to statically verify the correctness of a concrete implementation in their framework.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: I would try to combine type systems for sound programmable inference
and sound differentiable programming.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: I am thinking of &lt;em&gt;The Next XXX MCMC Algorithms&lt;/em&gt;.&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Quantum Probability and Bayesian Inference&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Quantum physics uses a form of complex probability. People have been
thinking of it as a serious probability theory (see &lt;a href=&#34;https://arxiv.org/abs/hep-th/9307019&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this&lt;/a&gt; and &lt;a href=&#34;https://en.wikipedia.org/wiki/Quantum_Bayesianism&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this&lt;/a&gt;).
There are even quantum analogs of Bayesian inference (&lt;a href=&#34;https://link.springer.com/chapter/10.1007/978-3-642-00834-4_5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;one&lt;/a&gt; and &lt;a href=&#34;https://arxiv.org/abs/2006.02256&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;the other&lt;/a&gt;). Does it make sense to incorporate some of those ideas in current probabilistic programming systems?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: I still have to learn quantum physics (emm, not really).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: Some people are trying to add quantum features
to standard Bayesian models (check out &lt;a href=&#34;https://www.informatyka.agh.edu.pl/media/uploads/qis_presentation12.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;this&lt;/a&gt;).&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;h3 id=&#34;program-synthesis&#34;&gt;Program Synthesis&lt;/h3&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Interface Synthesis for Database Tables&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: One central function of low-code programming platforms is to
automatically generate usable interface for manipulating database tables.
In an application, the developers might want to customize a specific way to
organize the interface, and they want to reuse the customization across the
application.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: The customization can be thought as a functor that takes a
database-table module as its input and outputs an inference module for that table.
For low-code programming, it would be useful to have a mechanism where
the developers customize a table interactively and the platform automatically
synthesize the code of the customization functor.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: Low-code programming involves many UI-related customization.
Is there a more general principle? For example, it might be interesting to
investigate &lt;a href=&#34;https://www.cs.cmu.edu/~NatProg/index.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Natural Programming&lt;/a&gt;.&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Resource-guided Synthesis and Implicit Computational Complexity&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Recently, resource-guided synthesis and algorithm synthesis have
received considerable attention&lt;sup id=&#34;fnref:23&#34;&gt;&lt;a href=&#34;#fn:23&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;23&lt;/a&gt;&lt;/sup&gt; &lt;sup id=&#34;fnref:24&#34;&gt;&lt;a href=&#34;#fn:24&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;24&lt;/a&gt;&lt;/sup&gt;.
We also had published a related &lt;a href=&#34;https://stonebuddha.github.io/publication/knothwp19&#34; target=&#34;_blank&#34;&gt;PLDI paper&lt;/a&gt;.
Those approaches can be categorized into two sorts: one develops a complex
type system of program logic to enforce resource guarantees, the other proposes
algorithmic templates that ensure resource guarantees.
The latter is somewhat related to &lt;a href=&#34;https://en.wikipedia.org/wiki/Implicit_computational_complexity&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Implicit Computational Complexity&lt;/a&gt; (ICC),
which characterizes algorithms by constraints on the way in which they are constructed.
In other words, an ICC research usually provides a non-standard programming language,
in which every legal program is guaranteed to have certain complexity.
Can we generalize the template-based approach to ICC-based approach?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: A starting point could be non-size-increasing computaion&lt;sup id=&#34;fnref:25&#34;&gt;&lt;a href=&#34;#fn:25&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;25&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: ICC seems to be not so fine-grained, e.g., usually researchers
focus on whether the complexity is polynomial or not. How to make them finer-grained?
For example, would it be possible to develop an ICC class for $O(n \log n)$ algorithms?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;h3 id=&#34;program-verification&#34;&gt;Program Verification&lt;/h3&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Verifying Time/Memory Complexities in VST&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: &lt;a href=&#34;https://vst.cs.princeton.edu/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Verified Software Toolchain&lt;/a&gt; (VST) is a set of verified tools that formally verify the
functional correctness of C programs using Hoare logic and separation logic.
I wonder if it is also convenient to verify resource-usage properties of C programs,
like their time or memory complexities.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: It has been shown that separation logic naturally supports
resource verification based on time credits&lt;sup id=&#34;fnref:26&#34;&gt;&lt;a href=&#34;#fn:26&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;26&lt;/a&gt;&lt;/sup&gt;. So conceptually it should
be possible to have that in VST.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: Can we develop some general reasoning libraries for resource
verification?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;details class=&#34;spoiler&#34;&gt;
  &lt;summary&gt;Backward Proving in Coq&lt;/summary&gt;
  &lt;span style=&#34;display:inline-block;margin-left:1.5em;&#34;&gt;
&lt;p&gt;&lt;strong&gt;Problem&lt;/strong&gt;: Coq proofs are organized in a forward, tactic-based manner, which is
not very readable. In contrast, Isabelle (and some other theorem provers) provides
a backward mode, where the intermediate goals are stated explicitly, so that improves
readability. Is it possible to use a backward pattern in Coq proofs? If not, would
it be possible to have a backward-proof DSL that can be translated to Coq?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Proposal&lt;/strong&gt;: Isabelle&amp;rsquo;s &lt;a href=&#34;https://isabelle.in.tum.de/Isar/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Isar&lt;/a&gt; might be a good starting point.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Follow-up&lt;/strong&gt;: What is the best proof interface for system programmers?&lt;/p&gt;
  &lt;/span&gt;
&lt;/details&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;Jan Hoffmann and Steffen Jost. Two Decades of Automatic Amortized Resource Analysis. &lt;em&gt;Math. Struct. Comput. Sci.&lt;/em&gt; (2022). &lt;a href=&#34;https://doi.org/10.1017/S0960129521000487&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;Vikash K. Mansinghka, Ulrich Schaechtle, Shivam Handa, Alexey Radul, Yutian Chen, and Martin Rinard.
Probabilistic Programming with Programmable Inference. &lt;em&gt;Prog. Lang. Design and Impl.&lt;/em&gt; (2018). &lt;a href=&#34;https://doi.org/10.1145/3192366.3192409&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34;&gt;
&lt;p&gt;Zachary Kincaid, Thomas Reps, and John Cyphert. Algebraic Program Analysis. &lt;a href=&#34;https://doi.org/10.1007/978-3-030-81685-8_3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34;&gt;
&lt;p&gt;Javier Esparza, Stefan Kiefer, and Michael Luttenberger. Newtonian Program Analysis. &lt;em&gt;J. ACM&lt;/em&gt; (2010). &lt;a href=&#34;https://doi.org/10.1145/1857914.1857917&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref1:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref2:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34;&gt;
&lt;p&gt;Kevin Batz, Adrian Gallus, Benjamin Lucien Kaminski, Joost-Pieter Katoen, and Tobias Winkler. Weighted Programming: A Programming Paradigm for Specifying Mathematical Models. &lt;em&gt;Object-Oriented Prog., Syst., Lang., and Applications&lt;/em&gt; (2022). &lt;a href=&#34;https://doi.org/10.1145/3527310&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34;&gt;
&lt;p&gt;Akash Lal, Tayssir Touili, Nicholas Kidd, and Thomas Reps. Interprocedural Analysis of Concurrent Programs Under a Context Bound. &lt;em&gt;Tools and Algor. for the Constr. and Anal. of Syst.&lt;/em&gt; (2008). &lt;a href=&#34;https://doi.org/10.1007/978-3-540-78800-3_20&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34;&gt;
&lt;p&gt;Thomas Reps, Emma Turetsky, and  Prathmesh Prabhu. Newtonian Program Analysis via Tensor Product. &lt;em&gt;Princ. of Prog. Lang.&lt;/em&gt; (2016). &lt;a href=&#34;https://doi.org/10.1145/2837614.2837659&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref1:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:8&#34;&gt;
&lt;p&gt;Mingshuai Chen, Joost-Pieter Katoen, Lutz Klinkenberg, and Tobias Winkler. Does a Program Yield the Right Distribution?. &lt;em&gt;Computer Aided Verif.&lt;/em&gt; (2022). &lt;a href=&#34;https://doi.org/10.1007/978-3-031-13185-1_5&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:8&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:9&#34;&gt;
&lt;p&gt;Matthew Might, Yannis Smaragdakis, and David Van Horn. Resolving and Exploiting the $k$-CFA Paradox: Illuminating Functional vs. Object-Oriented Program Analysis. &lt;em&gt;Prog. Lang. Design and Impl.&lt;/em&gt; (2010). &lt;a href=&#34;https://doi.org/10.1145/1806596.1806631&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:9&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:10&#34;&gt;
&lt;p&gt;Edsger W. Dijkstra. A Discipline of Programming. &lt;em&gt;Prentice Hall PTR&lt;/em&gt; (1997). &lt;a href=&#34;https://dl.acm.org/doi/book/10.5555/550359&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:10&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:11&#34;&gt;
&lt;p&gt;Nick Benton. Simple Relational Correctness Proofs for Static Analyses and Program Transformations. &lt;em&gt;Princ. of Prog. Lang.&lt;/em&gt; (2004). &lt;a href=&#34;https://doi.org/10.1145/982962.964003&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:11&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:12&#34;&gt;
&lt;p&gt;Christopher Pulte, Dhruv C. Makwana, Thomas Sewell, Kayvan Memarian, Peter Sewell, and Neel Krishnaswami. CN: Verifying Systems C Code with Separation-Logic Refinement Types. &lt;em&gt;Princ. of Prog. Lang.&lt;/em&gt; (2023). &lt;a href=&#34;https://doi.org/10.1145/3571194&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:12&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:13&#34;&gt;
&lt;p&gt;Michael Sammler, Rodolphe Lepigre, Robbert Krebbers, Kayvan Memarian, Derek Dreyer, and Deepak Garg. RefinedC: Automating the Foundational Verification of C Code with Refined Ownership Types. &lt;em&gt;Prog. Lang. Design and Impl.&lt;/em&gt; (2021). &lt;a href=&#34;https://doi.org/10.1145/3453483.3454036&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:13&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:14&#34;&gt;
&lt;p&gt;Nikhil Swamy, Joel Weinberger, Cole Schlesinger, Juan Chen, and Benjamin Livshits. Verifying Higher-order Programs with the Dijkstra Monad. &lt;em&gt;Prog. Lang. Design and Impl.&lt;/em&gt; (2013). &lt;a href=&#34;https://doi.org/10.1145/2491956.2491978&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:14&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:15&#34;&gt;
&lt;p&gt;Nikhil Swamy, Cătălin Hriţcu, Chantal Keller, Aseem Rastogi, Antoine Delignat-Lavaud, Simon Forest, Karthikeyan Bhargavan, Cédric Fournet, Pierre-Yves Strub, Markulf Kohlweiss, Jean-Karim Zinzindohoue, and Santiago Zanella-Béguelin. Dependent Types and Multi-monadic Effects in F*. &lt;em&gt;Princ. of Prog. Lang.&lt;/em&gt; (2016). &lt;a href=&#34;https://doi.org/10.1145/2837614.2837655&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:15&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:16&#34;&gt;
&lt;p&gt;Patrick M. Rondon, Ming Kawaguci, and Ranjit Jhala. Liquid Types. &lt;em&gt;Prog. Lang. Design. and Impl.&lt;/em&gt; (2008). &lt;a href=&#34;https://doi.org/10.1145/1379022.1375602&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:16&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:17&#34;&gt;
&lt;p&gt;Raven Beutner, Luke Ong, and Fabian Zaiser. Guaranteed Bounds for Posterior Inference in Universal Probabilistic Programming. &lt;em&gt;Prog. Lang. Design and Impl.&lt;/em&gt; (2022). &lt;a href=&#34;https://doi.org/10.1145/3519939.3523721&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:17&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:18&#34;&gt;
&lt;p&gt;Marcel Hark, Benjamin Lucien Kaminski, Jürgen Giesl, and Joost-Pieter Katoen. Aiming Low Is Harder: Induction for Lower Bounds in Probabilistic Program Verification. &lt;em&gt;Princ. of Prog. Lang.&lt;/em&gt; (2020). &lt;a href=&#34;https://doi.org/10.1145/3371105&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:18&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:19&#34;&gt;
&lt;p&gt;Zachary Kincaid, Jason Breck, Ashkan Forouhi Boroujeni, and Thomas Reps. Compositional Recurrence Analysis Revisited. &lt;em&gt;Prog. Lang. Design and Impl.&lt;/em&gt; (2017). &lt;a href=&#34;https://doi.org/10.1145/3062341.3062373&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:19&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:20&#34;&gt;
&lt;p&gt;Daniel J. Fremont, Tommaso Dreossi, Shromona Ghosh, Xiangyu Yue, Alberto L. Sangiovanni-Vincentelli, and Sanjit A. Seshia. Scenic: A Language for Scenario Specification and Scene Generation. &lt;em&gt;Prog. Lang. Design and Impl.&lt;/em&gt; (2019). &lt;a href=&#34;https://doi.org/10.1145/3314221.3314633&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:20&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:21&#34;&gt;
&lt;p&gt;Tejas D. Kulkarni, Pushmeet Kohli, Joshua B. Tenenbaum, and Vikash Mansinghka. Picture: A Probabilistic Programming Language for Scene Perception. &lt;em&gt;Comp. Vision and Pattern Recognition&lt;/em&gt; (2015). &lt;a href=&#34;https://doi.org/10.1109/CVPR.2015.7299068&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:21&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:22&#34;&gt;
&lt;p&gt;Marco Cusumano-Towner, Alexander K. Lew, and Vikash K. Mansinghka. Automating Involutive MCMC using Probabilistic and
Differentiable Programming. &lt;a href=&#34;https://arxiv.org/abs/2007.09871&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;arXiv&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:22&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:23&#34;&gt;
&lt;p&gt;Qinheping Hu, John Cyphert, Loris D’Antoni, and Thomas Reps. Synthesis with Asymptotic Resource Bounds. &lt;em&gt;Computer Aided Verif.&lt;/em&gt; (2021). &lt;a href=&#34;https://doi.org/10.1007/978-3-030-81685-8_37&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:23&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:24&#34;&gt;
&lt;p&gt;Yican Sun, Xuanyu Peng, and Yingfei Xiong. Synthesizing Efficient Memoization Algorithms. &lt;em&gt;Object-Oriented Prog., Syst., Lang., and Applications&lt;/em&gt; (2023).&amp;#160;&lt;a href=&#34;#fnref:24&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:25&#34;&gt;
&lt;p&gt;Martin Hofmann. Linear types and non-size-increasing polynomial time computation. &lt;em&gt;Logic in Computer Science&lt;/em&gt; (1999). &lt;a href=&#34;https://doi.org/10.1109/LICS.1999.782641&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:25&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:26&#34;&gt;
&lt;p&gt;Arthur Charguéraud and François Pottier. Machine-Checked Verification of the Correctness and Amortized Complexity of an Efficient Union-Find Implementation. &lt;em&gt;Interactive Theorem Proving&lt;/em&gt; (2015). &lt;a href=&#34;https://doi.org/10.1007/978-3-319-22102-1_9&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;DOI&lt;/a&gt;&amp;#160;&lt;a href=&#34;#fnref:26&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
