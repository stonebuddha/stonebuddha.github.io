<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Problem Solving | Di Wang</title>
    <link>https://stonebuddha.github.io/category/problem-solving/</link>
      <atom:link href="https://stonebuddha.github.io/category/problem-solving/index.xml" rel="self" type="application/rss+xml" />
    <description>Problem Solving</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Sat, 03 Nov 2018 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://stonebuddha.github.io/media/icon_hub0ca2310ff82550007847b11be674ab8_14787_512x512_fill_lanczos_center_3.png</url>
      <title>Problem Solving</title>
      <link>https://stonebuddha.github.io/category/problem-solving/</link>
    </image>
    
    <item>
      <title>Using FFT to Speed Up DP</title>
      <link>https://stonebuddha.github.io/post/using-fft-to-speed-up-dp/</link>
      <pubDate>Sat, 03 Nov 2018 00:00:00 +0000</pubDate>
      <guid>https://stonebuddha.github.io/post/using-fft-to-speed-up-dp/</guid>
      <description>&lt;p&gt;Problem link: &lt;a href=&#34;https://www.hackerrank.com/challenges/counting-road-networks&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Counting Road Networks | HackerRank&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You are supposed to count the number of connected undirected labeled graphs with $n$ vertices.
Algorithms with $O(n \log^2 n)$ time complexity are preferable.&lt;/p&gt;
&lt;h2 id=&#34;a-dynamic-programming-algorithm&#34;&gt;A Dynamic-Programming Algorithm&lt;/h2&gt;
&lt;p&gt;Let $f(n)$ be the answer for $n$.
The first idea to compute $f(n)$ is subtracting the number of disconnected graphs from the total number.
The total number of size-$n$ graphs is $g(n) := 2^{\binom{n}{2}}$.
How to count the disconnected graphs?
Let&amp;rsquo;s consider the size $m$ of the connected component containing the vertex labeled with 1.
Since the graph is disconnected, $m$ cannot be $n$.
Then the number of disconnected graphs where the connected component containing vertex 1 is a certain one with size $m$ is exactly $f(m) \cdot g(n-m)$.
Now we have an $O(n^2)$-time dynamic-programming algorithm as follows.
$$
f(n) = g(n) - \sum_{m=1}^{n-1} \binom{n-1}{m-1} \cdot f(m) \cdot g(n - m)
$$&lt;/p&gt;
&lt;h2 id=&#34;expression-rearrangement&#34;&gt;Expression Rearrangement&lt;/h2&gt;
&lt;p&gt;If we unfold the binomial coefficients, we will have
$$
\frac{f(n)}{(n-1)!} = n \cdot \frac{g(n)}{n!} - \sum_{m=1}^{n-1} \frac{f(m)}{(m-1)!} \cdot \frac{g(n-m)}{(n-m)!}
$$
Let $F(n) := \frac{f(n)}{(n-1)!}$ and $G(n) := \frac{g(n)}{n!}$.
Moreover, let&amp;rsquo;s set $F(0)$ to $0$ and then we have
$$
F(n) = n \cdot G(n) - \sum_{m=0}^{n-1} F(m) \cdot G(n-m)
$$
Note that we already have a convolution-like term in the formula.&lt;/p&gt;
&lt;h2 id=&#34;an-optimization-based-on-fft&#34;&gt;An Optimization Based on FFT&lt;/h2&gt;
&lt;p&gt;We will use &lt;a href=&#34;https://en.wikipedia.org/wiki/Fast_Fourier_transform&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Fast Fourier transform&lt;/a&gt; (FFT) as an $O(n \log n)$-time algorithm to compute convolution of length $n$.&lt;/p&gt;
&lt;p&gt;First of all, $G(n)$ are easy to compute so we can pre-process them.
Now we are going to use a divide-and-conquer scheme.
Let $solve(l,r)$ be a procedure that computes $F(n)$ for all $n \in [l,r)$.
In addition, we add the following invariant to this procedure:&lt;/p&gt;
&lt;p&gt;When invoking $solve(l,r)$, we already compute for each $n \in [l,r)$, the partial convolution $\sum_{m=0}^{l-1} F(m) \cdot G(n-m)$, and store them in $H(n)$.&lt;/p&gt;
&lt;p&gt;Then our algorithm proceeds as follows.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If $l+1=r$, we set $F(l)$ to $l \cdot G(l) - H(l)$.&lt;/li&gt;
&lt;li&gt;Otherwise, let&amp;rsquo;s invoke $solve(l,k)$ first where $k = \frac{l+r}{2}$, i.e., the middle point.
Now we already solve the first half of the problem.
To become able to invoke $solve(k,r)$ to complete the second half, we need to do something to maintain the invariant above.
In essence, we need to update
$$
H(n) \gets H(n) + \sum_{m=l}^{k-1} F(m) \cdot G(n-m)
$$
for each $n \in [k,r)$.
Here comes the chance for optimization.
What we really want to compute is the convolution of $F[l,k)$ and $G[0,r-l)$!
Let the convolution result be $C$ and indeed we have
$$
C(n) = \sum_{m=l}^{k-1}  F(m) \cdot G(n-m)
$$
for each $n \in [k,r)$.
After performing $H(n) \gets H(n) + C(n)$ for each $n \in [k,r)$, we reestablish the invariant and we can recurse to $solve(k,r)$.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Finally, let&amp;rsquo;s estimate the time complexity of the algorithm above.
Let $T(n)$ be the running time of $solve(l,r)$ with $n=r-l$.
By using FFT to compute the convolution, we can establish the following
$$
T(n) = 2T(\frac{n}{2}) + O(n \log n)
$$
Then by the Master Theorem we derive that $T(n) = O(n \log^2 n)$.&lt;/p&gt;
&lt;h2 id=&#34;whats-more&#34;&gt;What&amp;rsquo;s More&lt;/h2&gt;
&lt;p&gt;For those who could read Chinese, &lt;a href=&#34;https://www.cs.princeton.edu/~danqic/misc/divide-and-conquer.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CDQ&amp;rsquo;s divide-and-conquer&lt;/a&gt; is a good reference about applications of the divide-and-conquer scheme in this post.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
